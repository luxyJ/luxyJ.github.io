[{"title":"js几种常见排序算法","date":"2017-08-10T08:09:46.000Z","path":"2017/08/10/js几种常见排序算法/","text":"这里整理几种常用的排序，以后再加入其他的。 插入排序最普通的排序算法，把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列。 原理图： （插入操作要进行 n-1 次） 代码： 12345678910111213141516171819202122232425function insertSort(array)&#123; //假设第0个元素是一个有序的数列，第1个以后的是无序的序列， //所以从第1个元素开始将无序数列的元素插入到有序数列中 for(var i=1;i&lt;array.length;i++)&#123; if(array[i] &lt; array[i-1])&#123; //取出无序数列中的第i个作为被插入元素 var temp = array[i]; //记住有序数列的最后一个位置，并且将有序数列位置扩大一个 var j = i - 1; //比大小，找到被插入元素所在的位置 while(j &gt;= 0 &amp;&amp; temp &lt; array[j])&#123; array[j+1] = array[j]; j--; &#125; //插入 array[j+1] = temp; &#125; &#125;&#125;//var array = new Array(36,27,15,20,45,10);var array = [36,27,15,20,45,10];document.write(\"before: \" + array + \"&lt;br&gt;\");insertSort(array);document.write(\"after: \" + array); 算法分析： 最佳情况：输入数组按升序排列。T(n) = O(n) 最坏情况：输入数组按降序排列。T(n) = O(n^2) 平均情况：T(n) = O(n^2) 二分插入排序(折半插入排序)二分法插入排序是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。 原理图： （high&lt;low，查找结束，插入位置为low或high+1） 代码： 1234567891011121314151617181920212223function BinaryInsertSort(array)&#123; for(var i=1;i&lt;array.length;i++)&#123; var key = array[i]; var low = 0, high = i - 1; while(low &lt;= high)&#123; var mid = parseInt((low+high)/2); if(key&lt;array[mid])&#123; high = mid -1; &#125; else &#123; low = mid + 1; &#125; &#125; for(var j=i-1;j&gt;=low;j--)&#123; array[j+1] = array[j]; &#125; array[low] = key; //插入位置为low或high+1 &#125; return array;&#125;var array = [53,27,36,15,69,42];document.write(\"before: \" + array + \"&lt;br&gt;\");BinaryInsertSort(array);document.write(\"after: \" + array); 算法分析： 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n^2) 平均情况：T(n) = O(n^2) 冒泡排序(Bubble Sort)它重复地走访过要排序的数列，一次比较两个元素，每次遍历就将最大（或最小）值推至最前。越往后遍历查询次数越少， 跟插入排序刚好相反。 原理图： 代码： 12345678910111213141516function bubbleSort(array)&#123; for(var i=0;i&lt;array.length;i++)&#123; for(var j=array.length-1;j&gt;i;j--)&#123; if(array[j] &lt; array[j-1])&#123; var temp = array[j-1]; array[j-1] = array[j]; array[j] = temp; &#125; &#125; &#125; return array;&#125;var array = [53,27,36,15,69,42];document.write(\"before: \" + array + \"&lt;br&gt;\");bubbleSort(array);document.write(\"after: \" + array); 算法分析： 最佳情况：T(n) = O(n) 最差情况：T(n) = O(n^2) 平均情况：T(n) = O(n^2) 改进的冒泡排序如果在某次的排序中没有出现交换的情况，那么说明在无序的元素现在已经是有序了，就可以直接返回了 代码： 12345678910111213141516171819function bubbleSort(array)&#123; for(var i=0;i&lt;array.length;i++)&#123; var exchange = 0; for(var j=array.length-1;j&gt;i;j--)&#123; if(array[j] &lt; array[j-1])&#123; //使较小的元素浮在上面 var temp = array[j-1]; array[j-1] = array[j]; array[j] = temp; exchange = 1; &#125; &#125; if(!exchange) return array; &#125; return array;&#125;var array = [53,27,36,15,69,42];document.write(\"before: \" + array + \"&lt;br&gt;\");bubbleSort(array);document.write(\"after: \" + array); 快速排序在数据集之中，选择一个元素作为”基准”（pivot）。 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 原理图： 代码： 123456789101112131415161718var array = [36,53,27,20,15,69,42]; document.write(\"before: \" + array + \"&lt;br&gt;\"); function quickSort(array)&#123; if (array.length &lt;= 1) &#123;return array&#125;; var pivotIndex = Math.floor(array.length / 2); //pivot基准 var pivot = array.splice(pivotIndex,1); var left = []; var right = []; for (var i = 0; i &lt; array.length; i++)&#123; if(array[i] &lt; pivot) &#123; left.push(array[i]); &#125; else &#123; right.push(array[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right)); &#125; document.write(\"after: \" + quickSort(array)); 算法分析： 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n^2) 平均情况：T(n) = O(nlogn) 选择排序在无序区中选出最小的元素，然后将它和无序区的第一个元素交换位置。 原理图： 代码： 123456789101112131415161718function selectSort(array) &#123; for(var i=0;i&lt;array.length;i++)&#123; var min = array[i]; for(var j = i+1;j&lt;array.length-1;j++)&#123; if(min &gt; array[j])&#123; var temp = min; min = array[j]; array[j] = temp; &#125; &#125; array[i] = min; &#125; return array;&#125;var array = [53,27,36,15,69,42];document.write(\"before: \" + array + \"&lt;br&gt;\");selectSort(array);document.write(\"after: \" + array); 算法分析： 最佳情况：T(n) = O(n^2) 最差情况：T(n) = O(n^2) 平均情况：T(n) = O(n^2) 参考资料知乎-浅谈前端博客园-9种排序算法","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"正则表达式","date":"2017-08-08T11:33:30.000Z","path":"2017/08/08/正则表达式/","text":"正则表达式是对字符串操作的一种逻辑公式。 为什么使用正则表达式? 测试字符串内的模式 替换文本 基于模式匹配从字符串中提取子字符串 限定符 字符 描述 + 匹配前面的子表达式至少一次 * 匹配前面的子表达式零次或多次 ? 匹配前面的子表达式零次或一次 {n} n是一个非负整数,匹配确定的n次 {n,} n是一个非负整数,至少匹配n次 {n,m} m和n均为非负整数,其中n&lt;=m,最少匹配n次且最多匹配m次 *、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 例如，您可能搜索HTML文档，以查找括在H1标记内的章节标题。该文本在您的文档中如下： &lt;H1&gt;Chapter 1 - 介绍正则表达式&lt;/H1&gt; 贪婪： 下面的表达式匹配从开始小于符号(&lt;)到关闭H1标记的大于符号(&gt;)之间的所有内容： /&lt;.*&gt;/ 非贪婪： 如果您只需要匹配开始和介绍H1标记，下面的非贪婪表达式只匹配&lt;H1&gt;： /&lt;.*?&gt;/ 如果只想匹配开始的H1标签，表达式则是： /&lt;\\w+?&gt;/ 通过在*、+或?限定符之后放置?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。 定位符 字符 描述 ^ 匹配输入字符串开始的位置 $ 匹配输入字符串结尾的位置 \\b 匹配一个字边界，即字与空格间的位置 \\B 非字边界匹配 注意： 不能将限定符与定位符一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如^*之类的表达式。 运算符优先级下表从最高到最低说明了各种正则表达式运算符的优先级顺序： 运算符 描述 \\ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \\任何元字符、任何字符 定位点和序列(即：位置和顺序) I 替换，”或”操作 for example例1： 查找重复的单词 123var str = 'Is is the cost of of gasoline going up up';patt1 = /\\b([a-z]+) \\1\\b/gi;document.write(str.match(patt1)); //输出：Is is,of of,up up 解析： [a-z]+ 包含最少一个字母。\\1 指定第一个子匹配项。字边界元字符\\b确保只检测整个单词，否则，诸如 “is issued” 或 “this is” 之类的词组将不能正确地被此表达式识别。正则表达式后面的全局标记g指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。i标记指定不区分大小写。 例2： 分解URL 1234567var str = \"http://www.runoob.com:80/html/html-tutorial.html\";var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/;arr = str.match(patt1);for (var i = 0; i &lt; arr.length ; i++) &#123; document.write(arr[i]); document.write(\"&lt;br&gt;\");&#125; 解析： 这里分解为四个括号()来看。 第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。(“http”) 第二个括号子表达式捕获地址的域地址部分。子表达式匹配 / 和 : 之外的一个或多个字符。(“www.runoob.com”) 第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。(“:80”) 第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。(“/html/html-tutorial.html”) 例3： 一个小写字母和一位数字组成的字符串 /^[a-z][0-9]$/ 比如，z2,a4；但不能是ab2,r2d4。 例4： 第一个字符串不能是数字 /^[^0-9][0-9]$/ 这个模式与&amp;5,g7,-2是匹配的，但与12,66不是匹配的。下面是几个排除特定字符的例子： /[^a-z]/ //除了小写字母以外的所有字符 /[^\\\\\\/\\^]/ //除了(\\)(/)(^)之外的所有字符 /[^\\&quot;\\&apos;] //除了双引号(&quot;)和单引号(&apos;)之外的所有字符 例5： 更多的单词和数字 1234/^[a-zA-Z0-9_]&#123;1,&#125;$/ //所有包含一个以上的字母、数字或下划线的字符串/^[1-9][0-9]&#123;0,&#125;$/ //所有的正整数/^\\-&#123;0,1&#125;[0-9]&#123;1,&#125;$/ //所有的整数/^[-]?[0-9]+\\.?[0-9]+$/ //所有的浮点数 解释下上面的第4条：以一个可选的负号([-]?) 开头(^)、跟着一个或更多的数字([0-9]+)、和一个小数点(.) 再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。 由于特殊字符? 和 {0,1} 是相等的，它们都代表着：0个或1个前面的内容 或 前面的内容是可选的。所以上面第四条可以简化为： /^\\-?[0-9]{1,}\\.?[0-9]{1,}$/ 特殊字符* 和 {0,} 是相等的，它们代表着：0个或多个前面的内容 。 特殊字符+ 和 {1,} 是相等的，它们代表着：1个或多个前面的内容 。所以上面的4条可以改为： 1234/^[a-zA-Z0-9_]+$//^[1-9][0-9]*$//^\\-?[0-9]+$//^\\-?[0-9]+\\.?[0-9]+$/ 例6： 字符匹配 /a.c/ 可以匹配出的结果有aac,abc,acc,a4c,a#c等等。 常用正则表达式1.检验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 2.检测字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 3.特殊需求表达式 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?|&lt;.? /&gt; ( 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 正则表达式教程–菜鸟教程JavaScript RegExp 对象–W3school","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"JavaScript手册","date":"2017-08-05T14:51:43.000Z","path":"2017/08/05/JavaScript手册/","text":"JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。 Event对象之事件句柄(Event Handlers)onload &amp; onunload事件是在用户进入或者离开页面的时候被触发。onload事件可用于检测访问者的浏览器类型和浏览器版本;onload和onunload事件可用于处理cookie。 123456789&lt;body onload=\"checkCookies()\"&gt;function checkCookies() &#123; if(navigator.cookieEnabled = true)&#123; alert(\"Cookies可用\"); &#125; else &#123; alert(\"不可用\"); &#125;&#125;&lt;/body&gt; onchange事件在域的内容改变时发生。常结合对输入字段的验证来使用。 支持该事件的HTML标签：&lt;input type=&quot;text&quot;&gt; , &lt;select&gt; , &lt;textarea&gt; ; 支持该事件的JavaScript对象：fileUpload , select , text , textarea; 1234567输入你的名字：&lt;input type=\"text\" id=\"name\" onchange=\"myFunction()\"&gt;&lt;p&gt;当你离开输入框后，函数将被触发，将小写字母转为大写字母。&lt;/p&gt;function myFunction() &#123; var name = document.getElementById(\"name\"); name.value = name.value.toUpperCase();&#125; onmouseover &amp; onmouseout事件用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。 12345678&lt;div onmouseover=\"mOver(this)\" onmouseout=\"mOut(this)\" style=\"background: red;width: 120px;height: 120px;\"&gt;&lt;/div&gt;function mOut(obj) &#123; obj.innerHTML = \"Move Over Me\";&#125;function mOver(obj) &#123; obj.innerHTML = \"Thank you!\";&#125; onmousedown &amp; onmouseup &amp; onclick事件onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。 1234&lt;img id=\"img\" onmousedown=\"lighton()\" onmouseup=\"lightoff()\" src=\"http://www.runoob.com/try/demo_source/bulboff.gif\" width=\"100px\" height=\"180px\"&gt;function lightoff() &#123; document.getElementById('img').src=\"http://www.runoob.com/try/demo_source/bulboff.gif\";&#125; button事件指示当事件被触发时哪个鼠标按键被点击。语法：event.button = 0|1|2 。 参数 描述 0 规定鼠标左键 1 规定鼠标中键 2 规定鼠标右键 123456789101112&lt;body onmousedown=\"whichbutton(event)\"&gt;&lt;p&gt;click in the document!&lt;/p&gt;&lt;script&gt; function whichbutton(event) &#123; if(event.button == 2)&#123; alert(\"you click the right mouse button!\"); &#125; else &#123; alert(\"you click the left mouse button!\"); &#125; &#125;&lt;/script&gt;&lt;/body&gt; clientX &amp; clientY事件返回当事件被触发时鼠标指针向对于浏览器页面（或客户区：当前窗口）的水平坐标或者是垂直坐标。 12345678910&lt;body onmousedown=\"showCoords(event)\"&gt;&lt;p&gt;click in the document!&lt;/p&gt;&lt;script&gt; function showCoords(event) &#123; x = event.clientX; y = event.clientY; alert(\"X coords: \" + x + \",Y coords: \" + y); &#125;&lt;/script&gt;&lt;/body&gt; screenX &amp; screenY事件返回事件发生时鼠标指针相对于屏幕的水平坐标或者是垂直坐标。 DOM Element对象node.appendChild(node)向节点添加最后一个子节点: 12345678910&lt;ul id=\"myList\"&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;&lt;button onclick=\"myfunction()\"&gt;点击&lt;/button&gt;&lt;script&gt; function myfunction() &#123; var node = document.createElement(\"li\"); var textnode = document.createTextNode(\"water\"); node.appendChild(textnode); document.getElementById(\"myList\").appendChild(node); &#125;&lt;/script&gt; 从一个列表向另一个列表中移动列表项： 123456789&lt;ul id=\"myList1\"&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;&lt;ul id=\"myList2\"&gt;&lt;li&gt;water&lt;/li&gt;&lt;li&gt;milk&lt;/li&gt;&lt;/ul&gt;&lt;button onclick=\"myfunction()\"&gt;点击&lt;/button&gt;&lt;script&gt; function myfunction() &#123; var node = document.getElementById(\"myList2\").firstChild; document.getElementById(\"myList1\").appendChild(node); &#125;&lt;/script&gt; node.attributes返回指定节点的属性集合，即NamedNodeMap: 1234567&lt;button id=\"btn\" onclick=\"myFunction()\" class=\"btn\"&gt;点击&lt;/button&gt;&lt;script&gt; function myFunction() &#123; var x = document.getElementById(\"btn\").attributes.length; document.write(x); &#125;&lt;/script&gt; //输出结果：3 element.childNodes返回元素子节点的NodeList。 node.cloneNode(deep)创建节点的拷贝，并返回该副本。克隆所有属性以及它们的值。如果您需要克隆所有后代，请把deep参数设置true，否则设置为false。 123456789&lt;ul id=\"myList1\"&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;&lt;ul id=\"myList2\"&gt;&lt;li&gt;water&lt;/li&gt;&lt;li&gt;milk&lt;/li&gt;&lt;/ul&gt;&lt;button onclick=\"myFunction()\"&gt;点击&lt;/button&gt;&lt;script&gt;function myFunction() &#123; var clone = document.getElementById(\"myList2\").lastChild.cloneNode(true); document.getElementById(\"myList1\").appendChild(clone);&#125;&lt;/script&gt; node.insertBefore(newnode,existingnode)在已有子节点之前插入新的子节点: 123456789101112&lt;ul id=\"myList\"&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;&lt;button onclick=\"myFunction()\"&gt;点击&lt;/button&gt;&lt;script&gt;function myFunction() &#123; var newItem = document.createElement('li'); var textnode = document.createTextNode('water'); newItem.appendChild(textnode); var list = document.getElementById('myList'); list.insertBefore(newItem,list.childNodes[0]);&#125;&lt;/script&gt; node.nextSibling返回指定节点之后紧跟的节点，在相同的树层级中: 123&lt;ul id='myList'&gt;&lt;li id='item1'&gt;coffee&lt;/li&gt;&lt;li id='item2'&gt;tea&lt;/li&gt;&lt;/ul&gt;x = document.getElementById('item1').nextSibling.id;document.write(x); //输出：item2 node.parentNode以Node对象的形式返回指定节点的父节点: 123&lt;ul&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;x = document.getElementsByTagName('li')[0];document.write(x.parentNode.nodeName); //输出：UL Array对象concat() –连接连接两个或更多的数组，并返回结果。如果要进行concat()操作的参数是数组，那么添加的是数组中的元素，而不是数组。 12345var color = [\"Red\",\"Green\",\"Blue\"];var name = [\"Luya\",\"Awebone\"];var kei = [\"Robin\"];document.write(color.concat(name,kei));//输出：Red,Green,Blue,Luya,Awebone,Robin shift() &amp; pop() –删除shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 1234var color = [\"Red\",\"Green\",\"Blue\"];document.write(color+\"&lt;br&gt;\"); //输出：Red,Green,Bluedocument.write(color.shift()+\"&lt;br&gt;\"); //输出：Reddocument.write(color); //输出：Green,Blue pop()方法用于删除数组的最后一个元素并返回删除的元素。 1234var color = [\"Red\",\"Green\",\"Blue\"];document.write(color+\"&lt;br&gt;\"); //输出：Red,Green,Bluedocument.write(color.pop()+\"&lt;br&gt;\"); //输出：Bluedocument.write(color); //输出：Red,Green unshift() &amp; push() –增加unshift()方法可向数组的开头添加一个或更多元素，并返回新的长度。 123var color = [\"Red\",\"Green\",\"Blue\"];color.unshift(\"hello\",\"world\");document.write(color); //输出：hello,world,Red,Green,Blue push()方法可向数组的末尾添加一个或多个元素，并返回新的长度。 123var color = [\"Red\",\"Green\",\"Blue\"];color.push(\"hello\",\"world\");document.write(color); //输出：Red,Green,Blue,hello,world splice() –插入,删除,替换语法：array.splice(index,howmany,item1,...,itemX) index必须，规定从何处添加或删除元素；howmany必须，规定应该删除多少元素，必须为数字，可以为“0”，若为规定此参数，则删除从index开始到原数组结尾的所有元素；item可选，要添加到数组的新元素。 123var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];color.splice(2,0,\"luya\",\"awebone\");document.write(color); //输出：Red,Green,luya,awebone,Blue,pink 123var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];color.splice(2,1,\"luya\");document.write(color); //输出：Red,Green,luya,pink reverse() –颠倒reverse()方法用于颠倒数组中元素的顺序。 123var color = [\"Red\",\"Green\",\"Blue\"];document.write(color.reverse());//输出：Blue,Green,Red copyWithin() –拷贝copyWithin()方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中。 语法：array.copyWithin(target,start,end) target必须，从该位置开始替换数据；start必须，从该位置开始读取数据，默认为 0 。如果为负值，表示倒数；end可选，停止复制的索引位置(默认为array.length)。 1234567var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];document.write(color.copyWithin(0,1)+\"&lt;br&gt;\"); //Green,Blue,pink,pinkdocument.write(color.copyWithin(1,1)+\"&lt;br&gt;\"); //Red,Green,Blue,pinkdocument.write(color.copyWithin(2,1)+\"&lt;br&gt;\"); //Red,Green,Green,Bluedocument.write(color.copyWithin(3,1)+\"&lt;br&gt;\"); //Red,Green,Blue,Greendocument.write(color.copyWithin(2,3)+\"&lt;br&gt;\"); //Red,Green,pink,pink//上边的document要一条一条的输出，一起输出结果会变 sort() –排序sort()方法用于对数组的元素进行排序。排序顺序可以是字母或数字，并按升序或降序。默认排序顺序为按字母升序。 注意： 当数字是按字母顺序排列时”40”将排在”5”前面；使用数字排序，你必须通过一个函数作为参数来调用。 12var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];document.write(color.sort()); //输出：Blue,Green,Red,pink 数字排序(升序): 123var points = [40,20,1,5,12,23];points.sort(function (a,b)&#123; return a-b; &#125;);document.write(points); //输出：1,5,12,20,23,40 若要实现数字降序则改为：return b-a 。 some() –检测some()方法用于检测数组中的元素是否满足指定条件(函数提供)。会依次执行数组的每个元素，如果有一个元素满足条件，就返回true,剩下的元素不会在执行检测；如果没有满足条件的元素，则返回false。 12345var ages = [3,10,18,20];function check(age) &#123; return age &gt;= 18;&#125;document.write(ages.some(check)); //输出：true map() –处理map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 注意： some()和map()都不会对空数组进行检测。 12var num = [1,4,16,100];document.write(num.map(Math.sqrt)); //输出：1,2,4,10 join() –转换join()方法用于把数组中的所有元素转换一个字符串，元素是通过指定的分隔符进行分隔的。 12var color = [\"Red\",\"Green\",\"Blue\"];document.write(color.join(\" and \")); //输出：Red and Green and Blue fill() –填充fill()方法用于将一个固定值替换数组的元素。 语法：array.fill(value,start,end) 12var color = [\"Red\",\"Green\",\"Blue\"];document.write(color.fill(\"and\")); //输出：and,and,and 12var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];document.write(color.fill(\"and\",1,3)); //输出：Red,and,and,pink filter()filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 12345var ages = [32,15,18,7,39];function check(age)&#123; return age &gt;= 18;&#125;document.write(ages.filter(check)); //输出：32,18,39 菜鸟教程JavaScript Array对象 Date对象所有浏览器都支持date的各种方法。 123var d = new Date();//var d = new Date(year,month);document.write(d.getDate()); 方法 描述 备注 getDate() 返回一个月中的某一天 (1~31) / getDay() 返回一周中的某一天 (0~6) 周日是0，周一是1，依次类推 getFullYear() 返回一个表示年份的4位数字 / getMonth() 返回月份(0~11) 0(一月)到11(十二月) getHours() 返回Date对象的小时(0~23) 0表示(午夜) getMinutes() 返回Date对象的分钟(0~59) / getSeconds() 返回Date对象的秒数(0~59) / getMilliseconds() 返回Date对象的毫秒(0~999) / getTime() 返回1970年1月1日至今的毫秒数 / parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数 / setDate() 设置一个月的某一天 其他的方法类似，这里就不一一列举 toDateString() 把Date对象的日期部分转换为字符串 输出：Fri Aug 04 2017 toLocaleDateString() 根据本地时间格式，把Date对象的日期部分转换为字符串 输出：2017/8/4 toLocaleTimeString() 根据本地时间格式，把Date对象的时间部分转换为字符串 输出：上午10:59:41 toLocaleString() 据本地时间格式，把Date对象转换为字符串 输出：2017/8/4 上午11:00:36 setDate()方法: 123var d = new Date();d.setDate(15);document.write(d); //今天真是的是4号，输出：Tue Aug 15 2017 10:54:13 GMT+0800 (中国标准时间) getFullYear()方法： 12var d = new Date();document.write(d.getFullYear()); //输出：2017 getHours()方法： 12var d = new Date(\"July 21,2017 21:00:00\");document.write(d.getHours()); //输出：21 菜鸟教程JavaScipt Date对象 Math对象floor(x)对x进行下舍入，返回小于等于x的最大整数： 1document.write(Math.floor(1.6)); //输出：1 ceil(x)对x进行上舍入，返回大于等于x的最大整数： 1document.write(Math.ceil(1.4)); //输出：2 round(x)对x进行四舍五入： 1document.write(Math.round(1.4)); //输出：1 random()返回介于 0(包含) ~ 1(不包含) 之间的一个随机数： 12345678&lt;p id=\"demo\"&gt;点击按钮随机显示1到10之间的随机数：&lt;/p&gt;&lt;button onclick=\"myFunction()\"&gt;点击&lt;/button&gt;&lt;script&gt;function myFunction() &#123; var demo = document.getElementById(\"demo\"); demo.innerHTML = Math.floor(Math.random() * 10 + 1);&#125;&lt;/script&gt; max(x,y,…,n) &amp; min()max()返回两个指定的数中带有较大的值的那个数: 1document.write(Math.max(1,56,4,22,-8)); //输出：56 菜鸟教程JavaScipt Math对象 String对象substring() &amp; slice() &amp; substr() –提取substring()用于提取字符串中介于两个指定下标之间的字符: 语法：stringObject.substring(start,stop) 123var str=\"Hello world!\"document.write(str.substring(3)); //输出：lo world!document.write(str.substring(3,7)); //输出：lo w slice()可提取字符串的某个部分，并以新的字符串返回被提取的部分: 语法：stringObject.slice(start,end) 123var str=\"Hello happy world!\"document.write(str.slice(6)); //输出：happy world!document.write(str.slice(6,11)); //输出：happy substr()可在字符串中抽取从 start 下标开始的指定数目的字符: 语法：stringObject.substr(start,length) 123var str=\"Hello world!\"document.write(str.substr(3)); //输出：lo world!document.write(str.substr(3,7)); //输出：lo worl indexOf()返回某个指定的字符串值在字符串中首次出现的位置。对大小写敏感；如果要检索的字符串值没有出现，则该方法返回-1。 12345var str=\"Hello world!\"document.write(str.indexOf(\"Hello\") + \" \");document.write(str.indexOf(\"World\") + \" \");document.write(str.indexOf(\"world\"));//输出： 0 -1 6 RegExp对象RegExp对象表示正则表达式，它是对字符串执行模式匹配的强大工具。 直接量语法：/pattern/attributes 修饰符 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配(查找所有匹配而非在找到第一个匹配后停止) m 执行多行匹配 123var str = \"Visit W3School\";var patt1 = /w3school/i;document.write(str.match(patt1)); //输出：W3School 123var str=\"Is this all there is?\";var patt1=/is/gi;document.write(str.match(patt1)); //输出：Is,is,is 方括号 [abc]表达式：用于查找方括号之间的任何字符,方括号内的字符可以是任何字符或字符范围。 直接量语法：/[abc]/ 123var str = \"Is this all there is?\";var patt1 = /[a-h]/g;document.write(str.match(patt1)); //输出：h,a,h,e,e [^abc]：用于查找任何不在方括号之间的字符。 [0-9]：查找任何从0至9的数字。 [a-z]：查找任何从小写a到小写z的字符。 (red|blue|green)：查找任何指定的选项。 元字符 . : 查找单个字符，除了换行和行结束符。 12var str = \"That's hot!\";document.write(str.match(/h.t/g)); //输出：hat,hot \\w : 查找单词字符。单词字符包括：a-z、A-Z、0-9，以及下划线。 12var str = 'Give 100%!';document.write(str.match(/\\w/g)); //输出：G,i,v,e,1,0,0 \\W : 查找非单词字符。（上面的代码输出：%） \\d &amp; \\D : 查找数字/查找非数字字符。 \\s &amp; \\S : 查找空白字符/查找非空白字符。空白字符可以是： 空格符 (space character) 制表符 (tab character) 回车符 (carriage return character) 换行符 (new line character) 垂直换行符 (vertical tab character) 换页符 (form feed character) \\b : 匹配单词边界。在单词边界匹配的位置，单词字符后面或前面不与另一个单词字符直接相邻。请注意，匹配的单词边界并不包含在匹配中。换句话说，匹配的单词边界的长度为零。（不要与[\\b]混淆。）如果未找到匹配，则返回null。 注意：\\b元字符通常用于查找位于单词的开头或结尾的匹配。 例子： 1./\\bm/ 匹配 “moon” 中的 ‘m’,返回m； 2./oo\\b/ 不匹配 “moon” 中的 ‘oo’，因为 ‘oo’ 后面的 ‘n’ 是一个单词字符，返回null； 3./oon\\b/ 匹配 “moon” 中的 ‘oon’，因为 ‘oon’ 位于字符串的末端，后面没有单词字符，返回oon； 4./\\w\\b\\w/ 不匹配任何字符，因为单词字符之后绝不会同时紧跟着非单词字符和单词字符，返回null。 \\B : 匹配非单词边界。匹配位置的上一个和下一个字符的类型是相同的：即必须同时是单词，或必须同时是非单词字符。字符串的开头和结尾处被视为非单词字符。如果未找到匹配，则返回null 注意：\\B元字符通常用于查找不处在单词的开头或结尾的匹配。 \\n : 查找换行符。返回换行符被找到的位置。如果未找到匹配，则返回-1。 量词 n+ : 匹配包含至少一个n的任何字符串。 12var str = 'Hellooo World! Hello W3School!';document.write(str.match(/o+/g)); //输出：ooo,o,o,oo n* : 匹配包含零个或多个n的任何字符串。 例： 对l进行全局搜索，包括其后紧跟的一个或多个o： 12var str = 'Hellooo World! Hello W3School!';document.write(str.match(/lo*/g)); //输出：l,looo,l,l,lo,l n? : 匹配任何包含零个或一个n的字符串。 例： 对1进行全局搜索，包括其后紧跟的零个或一个0： 12var str = '1,100 or 1000';document.write(str.match(/10?/g)); //输出：1,10,10 n{x} : 匹配包含X个n的序列的字符串。 例： 对包含四位数字序列的子串进行全局搜索： 12var str = '100,1000 or 10000';document.write(str.match(/\\d&#123;4&#125;/g)); //输出：1000,1000 n{x,Y} : 匹配包含X至Y个n的序列的字符串。X和Y必须是数字。 例： 对包含三位至四位数字序列的子串进行全局搜索： 12var str = '100,1000 or 10000';document.write(str.match(/\\d&#123;3,4&#125;/g)); //输出：100,1000,1000 n{x,} : 匹配包含至少X个n的序列的字符串。 例： 对包含至少三位数字序列的子串进行全局搜索： 12var str = '100,1000 or 10000';document.write(str.match(/\\d&#123;3,4&#125;/g)); //输出：100,1000,1000 n$ : 匹配任何结尾为n的字符串。 例： 对字符串结尾的 “is” 进行全局搜索： 12var str = 'Is this his';document.write(str.match(/is$/g)); //输出：is ^n : 匹配任何开头为n的字符串。 例： 对字符串开头的 “is” 进行全局搜索： 12var str = 'Is this his';document.write(str.match(/^is/g)); //输出：Is ?=n : 匹配任何其后紧接指定字符串n的字符串。 例： 对其后紧跟 “all” 的 “is” 进行全局搜索： 123var str = 'Is this all there is';patt1 = /is(?=all)/;document.write(str.match(patt1)); //输出：is ?!n : 匹配其后没有紧接指定字符串n的任何字符串。 例： 对其后没有紧跟 “all” 的 “is” 进行全局搜索： 123var str = 'Is this all there is';patt1 = /is(?! all)/gi;document.write(str.match(patt1)); //输出：Is,is 定位符 ^ : 匹配输入字符串开始的位置。 $ : 匹配输入字符串结尾的位置。 RegExp对象方法 compile : 编译正则表达式。 exec : 检索字符串中指定的值。返回找到的值，并确定其位置。 test : 检索字符串中指定的值。返回true或false。 支持正则表达式的String对象的方法 search()用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 match()在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 replace()在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 split()把一个字符串分割成字符串数组。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"二叉树","date":"2017-08-03T10:48:00.000Z","path":"2017/08/03/二叉树/","text":"二叉树（Binary Tree）是n（n&gt;=0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。二叉树中每一个节点都是一个对象，每一个数据节点都有三个指针，分别是指向父母、左孩子和右孩子的指针。每一个节点都是通过指针相互连接的。相连指针的关系都是父子关系。 二叉树节点的定义12345struct binaryTreeNode&#123; int m_nValue; binaryTreeNode* m_pLeft; binaryTreeNode* m_pRight;&#125;; 五种基本形态 空二叉树 只有一个根节点 根节点只有左子树 根节点只有右子树 根节点既有左子树又有右子树 又： 拥有三个节点的普通树只有两种情况：2层或3层。但由于二叉树要分左右，于是就有了如图5种情况： 特殊二叉树 斜树 上图的第二、三个小树。 满二叉树 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树 完全二叉树是指最后一层左边是满的，右边可能满也可能不满，然后其余层都是满的。一个深度为k，节点个数为 2^k - 1 的二叉树为满二叉树（完全二叉树）。就是一棵树，深度为k，并且没有空位。 特点： 叶子结点只能出现在最下两层。 最下层的叶子一定集中在左部连续位置。 倒数第二层，若有叶子结点，一定都在右部连续位置。 如果结点度为1，则该结点只有左孩子。 同样结点树的二叉树，完全二叉树的深度最小。 性质 在二叉树的第i层上至多有2^(i-1)个结点(i&gt;=1) 深度为k的二叉树至多有2^k-1个结点(k&gt;=1) 各遍历特性 前序遍历 访问根节点 前序遍历左子树 前序遍历右子树 中序遍历 中序遍历左子树 访问根节点 中序遍历右子树 后序遍历 后序遍历左子树 后序遍历右子树 访问根节点 由二叉树得各遍历 先序遍历: ABDGCEF ; 中序遍历: DGBAECF ; 后序遍历: GDBEFCA ; 已知前序、中序遍历，求后序遍历 例： 前序遍历： GDAFEMHZ 中序遍历： ADEFGHMZ 解析: 1.根据前序遍历的特点，得到根节点是 G ; 2.观察中序遍历，知：ADEF是根节点的左子树，HMZ是根节点的右子树; 3.接下来，知道左子树的根节点为 D ; 4.同理，A 为 D 的左子树，EF 为右子树 5.右子树的根节点是 M ，依次，画出的结果如图： 那么，可以得到后序遍历顺序为：AEFDHZMG 已知中序、后序遍历，求前序遍历 例： 中序遍历: ADEFGHMZ 后序遍历: AEFDHZMG 解析： 1.由后序遍历知 G 为根节点,结合中序遍历知 ADEF 为左子树，HMZ 为右子树; 2.再观察后序遍历，知道 D 为左子树根节点， M 为右子树根节点; 3.分析结果如图：","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"jQuery手册","date":"2017-07-28T15:09:06.000Z","path":"2017/07/28/jQuery手册/","text":"jQuery是一个JavaScript函数库，极大的简化了JavaScript编程。 jQuery 版本 2 以上不支持 IE6、7、8 浏览器。如果需要支持 IE6/7/8，那么请选择1.9。你还可以通过条件注释在使用 IE6/7/8 时只包含进1.9。 &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;jquery-1.9.0.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;!--[if gte IE 9]&gt;&lt;!--&gt; &lt;script src=&quot;jquery-2.0.0.js&quot;&gt;&lt;/script&gt; &lt;!--&lt;![endif]--&gt; 添加jQuery： 官网下载 可以直接从百度CDN中引用jQuery：src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot; 语法文档就绪事件： $(document).ready(function(){ //代码部分 }); 这是为了防止文档在完全加载之前运行jquery代码。 选择器 语法 描述 $(“p”) 元素选择器 $(“#id”) id选择器 $(“.class”) class选择器 层级选择器 事件什么是事件？页面对不同访问者的响应叫做事件。 常用事件方法1.$(document).ready()2.click() &amp; dblclick()3.bind()将事件和函数绑定到元素上。为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数。 $(&quot;button&quot;).bind(&quot;click&quot;,function(){ $(&quot;p&quot;).show(); }); 4.on() &amp; off()在被选元素及子元素上添加一个或多个事件处理程序。使用on()方法添加的事件处理程序适用于当前及未来的元素（比如由脚本创建的新元素）。 $(&quot;p&quot;).on(&quot;click&quot;,function(){ alert(&quot;The paragraph was clicked.&quot;); }); 提示：如需移除事件处理程序，使用off()方法 $(&quot;button&quot;).click(function(){ $(&quot;p&quot;).off(&quot;click&quot;); }); 向元素添加多个事件处理程序： $(&quot;p&quot;).on({ mouseover:function(){$(&quot;body&quot;).css(&quot;background-color&quot;,&quot;lightgray&quot;);}, mouseout:function(){$(&quot;body&quot;).css(&quot;background-color&quot;,&quot;lightblue&quot;);}, click:function(){$(&quot;body&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);} }); 5.toggle()用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的click事件。 &lt;button&gt;请点击这里，来切换不同的背景颜色&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).toggle(function(){ $(&quot;body&quot;).css(&quot;background&quot;,&quot;green&quot;);} ,function(){ $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;red&quot;);} ,function(){ $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);} ); }); 6.mousedown() &amp; mouseup()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生mousedown事件: $(&quot;button&quot;).mousedown(function(){ $(&quot;p&quot;).slideToggle(); }); 当在元素上松开鼠标按钮时，会发生mouseup事件 7.focus() &amp; blur()当元素获得焦点时，发生focus事件;当元素失去焦点时发生blur事件: &lt;input type=&quot;text&quot; /&gt; $(&quot;input&quot;).focus(function(){ $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;#FFFFCC&quot;); }); $(&quot;input&quot;).blur(function(){ $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;#D6D6FF&quot;); }); 8.hover()光标悬停事件: $(&quot;p&quot;).hover(function(){ $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); },function(){ $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;pink&quot;); }); 9.1. event.targettarget属性规定哪个DOM元素触发了该事件: &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;h2&gt;这是另一个标题&lt;/h2&gt; &lt;p&gt;这是一个段落&lt;/p&gt; &lt;div&gt;&lt;/div&gt; $(&quot;p,h1,h2&quot;).click(function(event){ $(&quot;div&quot;).html(&quot;点击事件由一个 &quot; + event.target.nodeName + &quot; 元素触发&quot;); }); 9.2. event.pageX &amp; event.pageYpageX()属性是鼠标指针的位置，相对于文档的左边缘;pageY()属性是鼠标指针的位置，相对于文档的上边缘: &lt;p&gt;鼠标指针位于：&lt;span&gt;&lt;/span&gt;&lt;/p&gt; $(document).mousemove(function(e){ $(&quot;span&quot;).text(&quot;X:&quot; + e.pageX + &quot;,Y:&quot; + e.pageY); }) 10.trigger()触发被选元素的指定事件类型: &lt;input type=&quot;text&quot; name=&quot;FirstName&quot; value=&quot;Hello World&quot; /&gt; &lt;br/&gt; &lt;button&gt;激活input域的select事件&lt;/button&gt; $(&quot;input&quot;).select(function(){ $(&quot;input&quot;).after(&quot;文本被选中！&quot;); }); $(&quot;button&quot;).click(function(){ $(&quot;input&quot;).trigger(&quot;select&quot;); }); 使用Event对象来触发事件： $(&quot;input&quot;).select(function(){ $(&quot;input&quot;).after(&quot;文本被选中！&quot;); }); var e = jQuery.Event(&quot;select&quot;); $(&quot;button&quot;).click(function(){ $(&quot;input&quot;).trigger(e); }); 效果动画 animate() 语法：animate(styles,speed,easing,callback); $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({left:&apos;250px&apos;}); }); 参数styles中的css样式值 见：链接 注释：使用 “+=” 或 “-=” 来创建相对动画(relative animations) 隐藏/显示 hide(speed,callback); show(speed,callback); toggle(speed,callback); speed参数可以取值：slow,fast,normal,毫秒;callback参数是隐藏或显示完成后所执行的函数名称。 &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;button class=&quot;btn1&quot;&gt;Toggle&lt;/button&gt; $(&quot;.btn1&quot;).click(function(){ $(&quot;p&quot;).toggle(); }); 淡入淡出 fadeIn(speed,callback); fadeOut(speed,callback); fadeToggle(speed,callback); fadeTo(speed,opacity,callback); speed参数可以取值：slow,fast,normal,毫秒;opacity必需，规定淡入或淡出的透明度，介于0.00与1.00;callback参数是隐藏或显示完成后所执行的函数名称。 $(&quot;.btn1&quot;).click(function(){ $(&quot;p&quot;).fadeTo(1000,0.4); }); 滑动 slideDown(speed,callback); slideUp(speed,callback); slideToggle(speed,callback); speed参数可以取值：slow,fast,normal,毫秒;callback参数是隐藏或显示完成后所执行的函数名称。 $(&quot;.btn1&quot;).click(function(){ $(&quot;p&quot;).slideToggle(); }); stop()停止当前正在运行的动画: $(&quot;#stop&quot;).click(function(){ $(&quot;#box&quot;).stop(); }); 链(Chaining)$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000); jQuery HTML获得内容 – text()、html()、val()&lt;p&gt;名称: &lt;input type=&quot;text&quot; id=&quot;test&quot; value=&quot;菜鸟教程&quot;&gt;&lt;/p&gt; &lt;button&gt;显示值&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ alert(&quot;值为: &quot; + $(&quot;#test&quot;).val()); }); }); text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 设置或返回属性 – attr()1.返回属性： &lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot; id=&quot;runoob&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt; &lt;button&gt;显示 href 属性的值&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ alert($(&quot;#runoob&quot;).attr(&quot;href&quot;)); }); }); 2.设置属性： $(&quot;button&quot;).click(function(){ $(&quot;img&quot;).attr(&quot;width&quot;,&quot;180&quot;); }); 3.设置多个属性： $(&quot;img&quot;).attr({width:&quot;50&quot;,height:&quot;80&quot;}); 添加元素append() &amp; prepend()append是在被选元素的结尾(仍然在内部)插入内容;prepend是在被选元素的开头(仍然在内部)插入内容 $(&quot;p&quot;).append(&quot; &lt;b&gt;Hello world!&lt;/b&gt;&quot;); after() &amp; before()after在被选元素的之后插入内容;before在被选元素之前插入内容 $(&quot;p&quot;).before(&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); 删除元素remove()删除被选元素及其子元素,该方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。 empty()从被选元素移除所有内容，包括所有文本和子节点: &lt;div id=&quot;div1&quot; style=&quot;height:100px;width:300px;border:1px solid black;background-color:yellow;&quot;&gt;这是 div 中的一些文本。 &lt;p&gt;这是在div中的一个段落。&lt;/p&gt; &lt;p&gt;这是在div中的另外一个段落。&lt;/p&gt; &lt;/div&gt; &lt;button&gt;清空div元素&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;#div1&quot;).empty(); }); }); clone()生成被选元素的副本，包含子节点、文本和属性: &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;button&gt;复制每个 p 元素，然后追加到 body 元素&lt;/button&gt; $(&quot;button&quot;).click(function(){ $(&quot;body&quot;).append($(&quot;p&quot;).clone()); }); addClass() &amp; removeClass() &amp; toggleClass()&lt;div class=&quot;div1&quot;&gt;这是一些文本。&lt;/div&gt; &lt;button&gt;为第一个div元素添加类&lt;/button&gt; .blue{ color:blue; } $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;#div1&quot;).addClass(&quot;blue&quot;); }); }); CSS()方法设置css属性： $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;,&quot;font-size&quot;,&quot;200%&quot;); 遍历祖先 (向上遍历)1.parent() 返回被选元素的直接父元素，只会向上一级对DOM树进行遍历。 2.parsents() 从父元素开始，返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。返回包含零个、一个元素或多个元素的jquery对象。 3.closest() 从当前元素开始，获得匹配选择器的第一个祖先元素，从当前元素开始沿DOM树向上。返回包含零个或一个元素的jquery对象。（和.parents有点相似） $(&apos;li.item-a&apos;).closest(&apos;ul&apos;).css(&apos;background-color&apos;, &apos;red&apos;); //整个ul中的li元素颜色都会变红 4.parsentsUntil() 返回介于两个给定元素之间的所有祖先元素。 后代 (向下遍历)1.children() 返回被选元素的所有直接子元素，该方法只会向下一级对DOM树进行遍历。 $(&quot;div&quot;).children(&quot;.selected&quot;).css(&quot;color&quot;,&quot;blue&quot;); 2.find() 返回被选元素的后代元素，一路向下直到最后一个后代。 `$(&apos;li.item-ii&apos;).find(&apos;li&apos;).css(&apos;background-color&apos;,&apos;red&apos;);` 也可以使用给定的jquery集合或元素来进行筛选： var $allListElements = $(&apos;li&apos;); $(&apos;li.item-ii&apos;).find($allListElements).css(&apos;background-color&apos;,&apos;red&apos;); 3.contents() 获得匹配元素集合中每个元素的子节点，包括文本和注释节点。 &lt;p&gt;Hello&lt;a href=&quot;#&quot;&gt;Apple&lt;/a&gt;,how are you doing?&lt;/p&gt; &lt;script&gt; $(&quot;p&quot;).contents().filter(function(){ return this.nodeType != 1; }).wrap(&quot;&lt;b/&gt;&quot;); &lt;/script&gt; 同胞 (水平遍历)1.siblings() 返回被选元素的所有同胞元素: $(&quot;p&quot;).siblings(&quot;.selected&quot;).css(&quot;background&quot;, &quot;yellow&quot;); //查找每个 p 元素的所有类名为 &quot;selected&quot; 的所有同胞元素： 2.next() 返回被选元素的下一个同胞元素 过滤 (缩小搜索元素的范围)1.first() 返回被选元素的首个元素。 2.last() 返回被选元素的最后一个元素。 3.eq() 返回被选元素中带有指定索引号的元素。 .blue{ background-color:blue; } $(&quot;body&quot;).find(&quot;div&quot;).eq(2).addClass(&quot;blue&quot;); 如果提供负数，则指示从集合结尾开始的位置，而不是从开头开始。 4.filter() 允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 &lt;div&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(&quot;div&quot;).css(&quot;background&quot;, &quot;#c8ebcc&quot;) .filter(&quot;.middle&quot;) .css(&quot;border-color&quot;, &quot;red&quot;); &lt;/script&gt; 5.not() 和filter()方法相反。 others1.add() 将元素添加到匹配元素的集合中: $(&quot;div&quot;).css(&quot;border&quot;, &quot;2px solid red&quot;) .add(&quot;p&quot;) .css(&quot;background&quot;, &quot;yellow&quot;); 2.each() 对jQuery对象进行迭代，为每个匹配元素执行函数。 $(&quot;button).click(function(){ $(&quot;li&quot;).each(function(){ alert($(this).text()) }); }); 3.end() 结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。 &lt;ul class=&quot;first&quot;&gt; &lt;li class=&quot;foo&quot;&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li class=&quot;bar&quot;&gt;list item 3&lt;/li&gt; &lt;/ul&gt; $(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;, &apos;red&apos;) .end().find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;); 说明: 这条命令链检索第一个列表中类名为foo的项目，并把它们的背景设置为红色。end()会将对象还原为调用find()之前的状态，所以第二个find()查找的是&lt;ul class=&quot;first&quot;&gt;内的.bar&#39;，而不是在列表的&lt;li class=&quot;foo&quot;&gt;中查找，并将匹配元素的背景设置为绿色。最后的结果是第一个列表中的项目1和项目3被设置了带颜色的背景，而第二个列表中的项目没有任何变化。 DOM元素方法index()返回指定元素相对于其他指定元素的index位置： &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Soda&lt;/li&gt; &lt;/ul&gt; $(&quot;li&quot;).click(function(){ alert($(this).index()); }); toArray()以数组的形式返回jQuery选择器匹配的元素: x = $(&quot;li&quot;).toArray() for(i=0;i&lt;x.length;i++){ alert(x[i].innerHTML); } size()返回被jQuery选择器匹配的元素的数量: $(document).ready(function(){ alert($(&quot;li&quot;).size()); }); //输出结果：3 get()获得由选择器指定的DOM元素: &lt;p&gt;This is a paragraph&lt;/p&gt; &lt;button&gt;获得p DOM元素&lt;/button&gt; &lt;div&gt;&lt;/div&gt; $(&quot;button&quot;).click(function(){ x = $(&quot;p&quot;).get(0); $(&quot;div&quot;).text(x.nodeName + &quot;: &quot; + x.innerHTML); }); //输出结果：P: This is a paragraph AJAX！！AJAX 是与服务器交换数据的技术，通过后台加载数据，它在不重载全部页面的情况下，实现了对部分网页的更新。 什么是AJAX?AJAX = 异步JavaScript和XML (Asynchronous JavaScript and XML) AJAX load()方法语法：$(selector).load(URL,data,callback); &lt;div id=&quot;div1&quot;&gt;使用jquery AJAX修改文本内容&lt;/div&gt; &lt;button&gt;获取外部内容&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;#div1&quot;).load(&quot;/try/ajax/demo_test.txt&quot;); }); //此处的url是我引用过来的 });","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"使用HBuilder","date":"2017-07-25T16:03:21.000Z","path":"2017/07/26/使用HBuilder/","text":"HBuilder下载地址：HBuilder官网 HBuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。HBuilder的编写用到了Java、C、Web和Ruby。HBuilder本身主体是由Java编写，它基于Eclipse，所以顺其自然地兼容了Eclipse的插件。 HBuilder设置外部web服务器测试移动Web1.打开开发工具 工具右上角更改开发视图模式为“边改边看模式” 打开设置web服务器 2.设置外置服务器 选择“外置Web服务器” ☞ 右边“新建” 编辑服务配置界面，“名称”随意，“浏览器运行URL”填写本机ip地址 3.查看IP地址并配置web服务器1.地址查看方式：在命令行中输入ipconfig，找到IPv4的地址 2.填写在URL中，如图所示（要在IP地址后面加上HBuilder使用的端口8020）： 3.使用新建的myWeb外部服务器 4.扫码测试在“web浏览器”网址右边有一个二维码标志，点击，使用手机扫描测试 注意： 扫码测试需要电脑和手机在同一个局域网下！！！ 电脑运行： 手机扫码运行：","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"学习Sass","date":"2017-07-25T13:03:33.000Z","path":"2017/07/25/学习Sass/","text":"CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。这不是锦上添花，而恰恰是雪中送炭。 目前主流的三个预处理器： Less Sass Stylus 安装SassRuby下载链接http://rubyinstaller.org/downloads 安装过程中请注意勾选 Add Ruby executables to your PATH 安装完成后运行cmd输入ruby -v测试有没有安装成功。 若安装成功，使用Ruby自带的RubyGems系统安装Sass和Compass gem install sass gem install compass 这样就安装好了！ 如下sass常用更新、查看版本、sass命令帮助等命令： gem update sass sass -v sass -h 编译SassSass编译有很多种方式，如命令行编译模式、sublime插件SASS-Build 、编译软件koala 、前端自动化软件codekit 、Grunt打造前端自动化工作流grunt-sass 、Gulp打造前端自动化工作流gulp-ruby-sass等。 命令行编译：//单文件转换命令 sass input.scss output.css //单文件监听命令 sass --watch input.scss:output.css //如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录： sass --watch app/sass:public/stylesheets 四种编译排版//未编译样式 .box { width: 300px; height: 400px; &amp;-title { height: 30px; line-height: 30px; } } nested 编译排版格式：/*命令行内容*/ sass style.scss:style.css --style nested /*编译过后样式*/ .box { width: 300px; height: 400px; } .box-title { height: 30px; line-height: 30px; } expanded 编译排版格式/*命令行内容*/ sass style.scss:style.css --style expanded /*编译过后样式*/ .box { width: 300px; height: 400px; } .box-title { height: 30px; line-height: 30px; } compact 编译排版格式/*命令行内容*/ sass style.scss:style.css --style compact /*编译过后样式*/ .box { width: 300px; height: 400px; } .box-title { height: 30px; line-height: 30px; } compressed 编译排版格式/*命令行内容*/ sass style.scss:style.css --style compressed /*编译过后样式*/ .box{width:300px;height:400px}.box-title{height:30px;line-height:30px} 在webstrom中使用sassfile ☛ settings ☞ Tools ☞ File Watchers 双击配置Sass 嵌套CSS规则sass文件: #content { article { h1 { color: #333 } p { margin-bottom: 1.4em } } aside { background-color: #EEE } } 编译成css后： #content article h1 { color: #333 } #content article p { margin-bottom: 1.4em } #content aside { background-color: #EEE } 父选择器的标识符&amp;article a { color: blue; &amp;:hover { color: red } } 当包含父选择器标识符的嵌套规则被打开时，他不会像后代选择器那样进行拼接，而是 &amp; 被父选择器直接替换： article a { color: blue; } article a:hover { color: red } 子组合选择器和同层组合选择器： &gt; 、 + 和 ~article section { margin: 5px } article &gt; section { border: 1px solid #ccc } 第一个选择器会选择article下的所有命中section选择器的元素。第二个选择器只会选择article下紧跟着的子元素中命中section选择器的元素。 header + p { font-size: 1.1em } 在上例中，你可以用同层相邻组合选择器 + 选择header元素后紧跟的p元素。 article ~ article { border-top: 1px dashed #ccc } 你也可以用同层全体组合选择器 ~ ，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素。 例子： article { ~ article { border-top: 1px dashed #ccc } &gt; section { background: #eee } dl &gt; { dt { color: #333 } dd { color: #555 } } nav + &amp; { margin-top: 0 } } sass解开组合之后： article ~ article { border-top: 1px dashed #ccc } article &gt; footer { background: #eee } article dl &gt; dt { color: #333 } article dl &gt; dd { color: #555 } nav + article { margin-top: 0 } 嵌套属性重复编写border-style border-width border-color等非常烦人，所以在sass中，只要像以下这样书写就行： nav{ border: { style: solid; width: 1px; color: #ccc; } } 规则： 把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。 优点： 属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。 导入Sass文件随着你的样式表越来越多，我们要把大量样式分拆到多个文件中，使用 @import 规则。 使用sass部分文件举例来说，你想导入 themes/_night-sky.scss 这个局部文件里的变量，你只需在样式表中写 @import &quot;themes/night-sky&quot;; 默认变量值;一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明： $link-color: blue; $link-color: red; a { color: $link-color; } 在上边的例子中，超链接的color会被设置为red。这可能并不是你想要的结果，假如你写了一个可被他人通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值。使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。 $fancybox-width: 400px !default; .fancybox { width: $fancybox-width; } 在上例中，如果用户在导入你的sass局部文件之前声明了一个$fancybox-width变量，那么你的局部文件中对$fancybox-width赋值400px的操作就无效。如果用户没有做这样的声明，则$fancybox-width将默认为400px。 静默注释body { color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */ } 混合器混合器使用 @mixin 标识符定义。 @mixin rounded-corners { -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px; } 然后就可以在样式表中通过 @include 来使用这个混合器。 notice { background-color: green; border: 2px solid #00aa00; @include rounded-corners; } sass最终生成： .notice { background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px; }","tags":[{"name":"css预处理器","slug":"css预处理器","permalink":"http://yoursite.com/tags/css预处理器/"}]},{"title":"HTML5 Web存储","date":"2017-07-24T06:02:21.000Z","path":"2017/07/24/HTML5-Web存储/","text":"HTML5使用JavaScript来存储和访问数据，提供了两种在客户端存储数据的新方法： localStorage –没有时间限制的数据存储。第二天、第二周或下一年之后，数据依然可用。 sessionStorage –针对一个session的数据存储。当用户关闭浏览器窗口后，数据会被删除。 localStorage方法对用户访问页面的次数进行计数： &lt;script&gt; if (localStorage.pagecount) { localStorage.pagecount=Number(localStorage.pagecount) +1; } else { localStorage.pagecount=1; } document.write(&quot;Visits &quot;+ localStorage.pagecount + &quot; time(s).&quot;); &lt;/script&gt; sessionStorage方法用户在当前 session 中访问页面的次数进行计数： &lt;script&gt; if(sessionStorage.pageCount){ sessionStorage.pageCount = Number(sessionStorage.pageCount) +1; } else { sessionStorage.pageCount = 1; } document.write(&quot;visits: &quot; + sessionStorage.pageCount + &quot; 次&quot;); &lt;/script&gt; 如何工作?早在1995,2010年，浏览器存储是利用cookie在浏览器上存储信息，但cookie仅限4k数据。 现如今的浏览器都很慷慨，都会提供5~10M（每个域）的存储空间。创建HTML5的本地存储时还充分考虑了Web应用（和移动应用）。所谓本地存储，就是指你的应用可以把数据存储在浏览器上，从而减少与服务器之间所需的通信。 如何做到的？ 使用这个API，页面可以在浏览器的本地存储中存储一个或多个键/值对； 然后用键来获取相应的值； 键/值对，就是key: &quot;pet&quot;, key就是键，pet就是对。 获取方法和设置方法(getItem和setItem)setItem方法，用于存储某个数据，只能是string类型的数据项。 localStorage.setItem(&quot;name&quot;,&quot;luya&quot;); localStorage.setItem(&quot;age&quot;,21); alert(localStorage.getItem(&quot;name&quot;)); //alert(parseInt(localStorage.getItem(&quot;age&quot;))); //输出：luya 看成一个关联数组//为键赋值 localStorage[&quot;name&quot;] = &quot;luya&quot;; //获取一个键存储的值,相当于getItem方法 var name = localStorage[&quot;name&quot;]; 另外两个特性length属性，localStorage中有多少数据项；key方法，给出localStorage中各个数据项的键。 for(var i=0;i&lt;localStorage.length;i++){ var key = localStorage.key(i); var value = localStorage[key]; alert(value); } 可以怎样使用？ 在我的新Twitter客户端，为了提高效率，我要用localStorage把Twitter搜索结果缓存起来。用户搜索时，会先搜索本地结果。这对移动用户很有帮助。 用户存储播放列表（影片、音乐等） 使用sessionStorage实现购物车 有一个非常酷的游戏，他可以在两个不同的浏览器窗口同时工作，使用localStorage完成状态同步 JSON JavaScript对象表示法（JavaScript Object Notation） JSON是存储和交换文本信息的语法，类似XML；JSON比XML更小、更快、更易解析。 JSON API只有两个方法：stringify 和 parse","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"JSP学习笔记","date":"2017-07-23T14:19:34.000Z","path":"2017/07/23/JSP学习笔记/","text":"JSP – Java Server Pages 区别jsp和servlet1.jsp就是在html里面写java代码，servlet就是在java里面写html代码。 2.servlet在java代码中通过HttpServletResponse对象动态输出HTML内容；jsp在静态HTML内容中嵌入Java代码，Java代码被动态执行后生成HTML内容。 3.两者通过MVC双剑合璧：MVC(Model-View-Controller) Controller(控制器) -负责转发请求，对请求进行处理 View(视图) -负责界面显示 Model(模型) -业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现 工具myeclipse,tomcat 使用myeclipse1.new – web project; 2.输入project name (imoocjsp); 3.打开imoocjsp 下的 Webroot 文件，双击index.jsp。删除pageEncoding=&quot;ISO-8859-1&quot;之后 使用 alt+/ 选择contentType,将其中charset值改为charset=utf-8;(解决中文编码问题) 4.点击图中红色区域内图标，选择Project – imoocjsp – add – Server – tomcat7 –ok; 5.启动Tomcat服务器，在地址栏输入：localhost:8080/imoocjsp/index.jsp JSP指令用来设置与整个JSP页面相关的属性。语法：&lt;%@ directive attribute=&quot;value&quot; %&gt; include 指令: &lt;%@ include file=&quot;url&quot; %&gt; 动作：&lt;jsp:include page=&quot;url&quot; flush=&quot;true|false&quot; /&gt; page(要包含的页面)； flush(被包含的页面是否从缓冲区读取) JSP注释 HTML注释： //客户端可见 JSP注释： &lt;%– html注释 –%&gt; //客户端不可见 JSP脚本注释： //单行注释 / ** /多行注释 JSP脚本写在&lt;% %&gt; 中的叫做JSP脚本。 &lt;% out.println(&quot;大家好，JSP脚本&quot;); %&gt; JSP声明在JSP页面中定义变量或者方法。语法：&lt;%! JAVA代码 %&gt; &lt;%! String s=&quot;张三&quot;; //声明了一个字符串变量 int add(int a,int b){ //声明了一个返回整型函数，实现两个整数的求和 return a+b; } %&gt; JSP表达式语法：&lt;%=表达式 %&gt;注意：表达式不以分号结束 做一个九九乘法表&lt;%! String printMultiTable() { String s=&quot;&quot;; for(int i=1;i&lt;=9;i++) { for(int j=1;j&lt;=i;j++) { s+=i+&quot;*&quot;+j+&quot;=&quot;+(i*j)+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;; } s+=&quot;&lt;br&gt;&quot;; } return s; } %&gt; &lt;h1&gt;九九乘法表&lt;/h1&gt;&lt;br&gt; &lt;%=printMultiTable() %&gt; JSP内置对象out对象 什么事缓冲区？ Buffer,所谓缓冲区就是内存的一块区域来保存临时数据。 &lt;% out.println(&quot;&lt;h2&gt;静夜思&lt;/h2&gt;&quot;); out.println(&quot;床前明月光&lt;br&gt;&quot;); out.clear(); out.println(&quot;疑是地上霜&lt;br&gt;&quot;); %&gt; 缓冲区大小：&lt;%=out.getBufferSize() %&gt;Byte&lt;br&gt; 缓冲区剩余大小：&lt;%=out.getRemaining() %&gt;&lt;br&gt; 缓冲区满时：&lt;%=out.isAutoFlush() %&gt;&lt;br&gt; get/postmethod=”get/post” get: 提交的数据最多不超过2KB，安全性较低但效率比post高。适合提交数据量不大。安全性不高的数据。比如：搜索、查询等功能。 post: 将用户提交的信息封装在HTML HEADER内。适合提交数据量大，安全性高的用户信息。比如：注册、修改、上传等功能。 用户名: 密码: request/response //login.jsp: &lt;form action=&quot;request.jsp&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 爱好:&lt;input type=&quot;checkbox&quot; name=&quot;favorite&quot; value=&quot;read&quot;&gt;读书 &lt;input type=&quot;checkbox&quot; name=&quot;favorite&quot; value=&quot;music&quot;&gt;音乐 &lt;input type=&quot;checkbox&quot; name=&quot;favorite&quot; value=&quot;movie&quot;&gt;电影 &lt;input type=&quot;checkbox&quot; name=&quot;favorite&quot; value=&quot;internet&quot;&gt;上网 &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;a href=&quot;request.jsp?username=lisi&quot;&gt;测试URL传参数&lt;/a&gt; //request.jsp: &lt;% request.setCharacterEncoding(&quot;utf-8&quot;); //解决中文乱码问题 %&gt; 用户：&lt;%=request.getParameter(&quot;username&quot;) %&gt;&lt;br/&gt; 爱好：&lt;% if(request.getParameterValues(&quot;favorite&quot;)!=null){ String[] favorites=request.getParameterValues(&quot;favorite&quot;); for(int i=0;i&lt;favorites.length;i++){ out.println(favorites[i]+&quot;&amp;nbsp;&amp;nbsp;&quot;); } } %&gt; %&gt; sessionapplicationpage对象JavaBeanjavabean是一种规范，而不是一种技术或工具。 创建JavaBean 新建一个Web Project –命名：JavaBeanDemo1 ； 新建一个package –命名：com.po ； 新建一个class –命名：Users ； 右键 – source – Generate getters and setters – Select All –ok ； 双击index.jsp – 使用page指令 &lt;%@ page import=&quot;com.po.Users&quot; %&gt; &lt;% Users user = new Users(); user.setUsername(&quot;admin&quot;); //设置用户名 user.setPassword(&quot;123456&quot;); //设置密码 %&gt; 用户名：&lt;%=user.getUsername() %&gt;&lt;br&gt; 密码：&lt;%=user.getPassword() %&gt;&lt;br&gt; JavaBean动作元素 &lt;jsp:useBean id=&quot;myUsers&quot; class=&quot;com.po.Users&quot; scope=&quot;page&quot; /&gt; &lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot; * &quot;/&gt; &lt;jsp:getProperty name=&quot;myUsers&quot; property=&quot; * &quot;/&gt;","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"git学习笔记","date":"2017-07-22T02:52:20.000Z","path":"2017/07/22/git学习笔记/","text":"Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 创建版本库(repository)首先在合适的地方(我选择在github/Git/usr中)，创建一个空目录： $ mkdir learngit $ cd learngit $ pwd /usr/learngit pwd命令用于显示当前目录 第二步，初始化仓库，在Git/usr中，输入命令 git init, 这样瞬间Git就把仓库建好了，而且会告诉你是一个空的仓库，此时你会看到多了一个.git目录 如果你没有看到，那是因为这个目录被隐藏了，用ls -ah命令就可以看到。 把文件添加到版本库先编写一个readme.txt 文件，内容如下 Git is a version control system. Git is free software. 第一步，把文件添加到仓库 $ git add readme.txt 第二步，把文件提交到仓库 $ git commit -m &quot;add readme.txt&quot; 修改readme.txt文件接着上面的内容，继续修改readme.txt文件，改成一下内容： Git is a distributed version control system. Git is free software. 掌握仓库当前的状态： $ git status 上图告诉我们，readme.txt被修改过,但还没有准备提交的修改 如果说过了很久，你忘了自己修改了什么内容，那么使用下面的命令就可以知道了： $ git diff &quot;文件名&quot; 接下来使用之前的 git add readme.txt , git commit -m &quot;add distributed&quot; 版本回退1.查看修改的历史记录(显示是从近到远)： $ git log 也可以加上参数 --pretty=oneline让历史记录看起来更简单。 2.退回上一个版本： $ git reset --hard HEAD^ 3.可是这个时候又想回到之前的版本怎么办，别急，只要你的命令行窗口没关掉，就往上找到append GPL 的 commit id是 ee0a0cff...(版本号只要前几位就行，git会自动查找) $ git reset --hard ee0a0cff 那要是命令行窗口关掉了呢？不怕，还是有办法的！Git提供了一个命令 git reflog 用来记录你的每一次命令。 删除文件$ git rm readme.txt 上传到github完整过程 –添加远程库echo &quot;#DemoWebsite&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin https://github.com/luyaJ/DemoWebsite.git git push -u origin master 分支管理创建others分支，并切换到others分支$ git checkout -b others 相当于下面的命令： $ git branch others $ git checkout others 查看当前分支$ git branch 切换回master分支$ git checkout master 合并分支$ git merge others 删除分支分支用完合并后就可以随意删除了： $ git branch -D others 总结 创建空目录三步走：mkdir 目录名字 ， cd 目录名字 ， pwd 初始化仓库：git init 添加文件到仓库：git add 文件名 提交文件到仓库：git commit -m “XXXX”(注意每次修改，如果不add到暂存区，那就不会加入到 commit中) 掌握仓库当前的状态：git status 查看文件修改内容： git diff “文件名” 查看修改的历史记录: git log 删除文件：git rm 文件名 最后附上廖雪峰老师的Git教程","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"用css实现几个小图标","date":"2017-07-21T05:25:59.000Z","path":"2017/07/21/用css实现几个小图标/","text":"1. 三角形 设置一个块元素大小为0，采用border属性，制作如下各种图形： //1.双色正方形 height: 0; width: 0; border-bottom: 100px solid indianred; border-left: 100px solid chocolate; //2.三色矩形 border-right: 100px solid darkcyan; //3.四色正方形 border-top: 100px solid plum; //4.三角形 height: 0; width: 0; border-bottom: 100px solid indianred; border-left: 100px solid transparent; border-right: 100px solid transparent; 2.陌陌轮廓使用圆角属性制作~直接上代码 height: 100px; width: 100px; background: darkgoldenrod; border-radius: 50% 50% 0; 进一步拓展，制作成小水滴： height: 100px; width: 100px; background: sandybrown; border-radius: 50% 50% 0; transform: rotate(45deg); 3.扭曲的正方形height: 100px; width: 100px; background: mediumslateblue; border-radius: 20px 12px 40px / 0.5em 3em; 其中的border-radius: 2em 1em 4em / 0.5em 3em;等价于： border-top-left-radius: 2em 0.5em; border-top-right-radius: 1em 3em; border-bottom-right-radius: 4em 0.5em; border-bottom-left-radius: 1em 3em; 注释: 如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。 4.箭头.demo{ width: 0; height: 0; border-top: 15px solid transparent; border-right: 15px solid red; -webkit-transform: rotate(10deg); -o-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); } .demo:after{ content: &quot;&quot;; position: absolute; border-top: 5px solid red; border-radius: 20px 0 0 0; top: -18px; left: -10px; width: 15px; height: 15px; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); } 5.小星星思想：三个三角形拼接而成，使用transform调整方向。 .star{ margin: 100px 0; color: red; height: 0; width: 0; border-right: 100px solid transparent; border-bottom: 70px solid darkkhaki; border-left: 100px solid transparent; -webkit-transform: rotate(35deg); -o-transform: rotate(35deg); -moz-transform: rotate(35deg); -ms-transform: rotate(35deg); } .star:before{ content: &apos;&apos;; height: 0; width: 0; border-bottom: 80px solid darkkhaki; border-left: 30px solid transparent; border-right: 30px solid transparent; position: absolute; top: -56px; left: -77px; -webkit-transform: rotate(-35deg); -moz-transform: rotate(-35deg); -ms-transform: rotate(-35deg); -o-transform: rotate(-35deg); } .star:after{ content: &apos;&apos;; width: 0; height: 0; border-right: 100px solid transparent; border-bottom: 70px solid darkkhaki; border-left: 100px solid transparent; position: absolute; color: red; top: 10px; left: -115px; -webkit-transform: rotate(-70deg); -moz-transform: rotate(-70deg); -ms-transform: rotate(-70deg); -o-transform: rotate(-70deg); } 6.心形.heart{ width: 100px; height: 90px; } .heart:before, .heart:after { position: absolute; content: &apos;&apos;; width: 50px; height: 80px; background: darksalmon; border-radius: 50px 50px 0 0; left: 50px; -webkit-transform: rotate(-45deg); -o-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -moz-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -ms-transform-origin: 0 100%; -o-transform-origin: 0 100%; transform-origin : 0 100%; } .heart:after{ left: 0; -webkit-transform: rotate(45deg); -o-transform: rotate(45deg); -ms-transform: rotate(45deg); -moz-transform: rotate(45deg); transform: rotate(45deg); -webkit-transform-origin: 100% 100%; -moz-transform-origin: 100% 100%; -ms-transform-origin: 100% 100%; -o-transform-origin: 100% 100%; transform-origin :100% 100%; } 7.十字架.cross{ height: 100px; width: 20px; background: mediumseagreen; margin-left: 50px; position: relative; } .cross:after{ background: mediumseagreen; content: &apos;&apos;; height: 20px; position: absolute; width: 80px; top: 30px; left: -30px; }","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Yilia主题优化","date":"2017-07-15T09:56:56.000Z","path":"2017/07/15/Yilia主题优化/","text":"过了大半年，该是要好好整理下自己的博客了。 github+hexo新建文章：$ hexo new &quot;新的文章&quot; 然后你就发现blog根目录下的source文件夹中的_post文件夹中多了一个 新的文章.md 文件 本地服务预览：$ hexo s //server （会监视文件变动并自动更新） 觉得自己的文章没问题后，就通过hexo g , hexo d生成和部署网页 清除缓存：$ hexo clean 生成：$ hexo g //generate 部署：$ hexo d //deploy 上面两部可以合起来 $ hexo d -g hexo所有主题传送门 markdown语法 markdownPad下载 推荐几个我觉得不错的主题： Ochuuunn / github下载 Random / github下载 安装主题$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 配置修改hexo根目录下的_config.yml ： theme : yilia 更新$ cd themes/yilia $ git pull 上面是老东西，下面是优化 添加文章目录添加css样式打开themes\\yilia\\source下的 main.2d7529.css文件(这里好像名字会不一样，没关系，找到.css文件就ok了)，在里面添加代码： /* 新添加的 */ #container .show-toc-btn,#container .toc-article{display:block} .toc-article{z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px}.toc-article .toc-close{font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc}.toc-article .toc-close:hover{color:#000}.toc-article .toc{font-size:12px;padding:0;line-height:20px}.toc-article .toc .toc-number{color:#333}.toc-article .toc .toc-text:hover{text-decoration:underline;color:#2a6496}.toc-article li{list-style-type:none}.toc-article .toc-level-1{margin:4px 0}.toc-article .toc-child{}@-moz-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@-webkit-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@-o-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}.show-toc-btn{display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9}.show-toc-btn .btn-bg{margin-top:2px;display:block;width:16px;height:14px;background:url(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%}.show-toc-btn .btn-text{color:#999;font-size:12px}.show-toc-btn:hover{cursor:pointer}.show-toc-btn:hover .btn-bg{background-position:0 -16px}.show-toc-btn:hover .btn-text{font-size:12px;color:#ea8010} .toc-article li ol, .toc-article li ul { margin-left: 30px; } .toc-article ol, .toc-article ul { margin: 10px 0; } 修改article.ejs文件打开themes\\yilia\\layout\\_partial文件夹下的article.ejs文件，在&lt;/header&gt; &lt;% } % 下面加入如下内容(注意插入的位置): &lt;!-- 目录内容 --&gt; &lt;% if (!index &amp;&amp; post.toc){ %&gt; &lt;p class=&quot;show-toc-btn&quot; id=&quot;show-toc-btn&quot; onclick=&quot;showToc();&quot; style=&quot;display:none&quot;&gt; &lt;span class=&quot;btn-bg&quot;&gt;&lt;/span&gt; &lt;span class=&quot;btn-text&quot;&gt;文章导航&lt;/span&gt; &lt;/p&gt; &lt;div id=&quot;toc-article&quot; class=&quot;toc-article&quot;&gt; &lt;span id=&quot;toc-close&quot; class=&quot;toc-close&quot; title=&quot;隐藏导航&quot; onclick=&quot;showBtn();&quot;&gt;×&lt;/span&gt; &lt;strong class=&quot;toc-title&quot;&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function showToc(){ var toc_article = document.getElementById(&quot;toc-article&quot;); var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;); toc_article.setAttribute(&quot;style&quot;,&quot;display:block&quot;); show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:none&quot;); }; function showBtn(){ var toc_article = document.getElementById(&quot;toc-article&quot;); var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;); toc_article.setAttribute(&quot;style&quot;,&quot;display:none&quot;); show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:block&quot;); }; &lt;/script&gt; &lt;% } %&gt; &lt;!-- 目录内容结束 --&gt; 如果想要文章显示目录，要在每篇文章的开头加入：toc: true 添加其他一些东西添加“关于”$ hexo new page &quot;about&quot; 此时，source中就会多出一个文件夹，名为about,可以在里面编辑内容 在themes/yilia/_config.yml添加下面内容： menu: 关于: /about 添加RSS$ npm install hexo-generator-feed --save 注意完整的输入上面的代码，--save不能省，否则插件信息不能写入package.json，之后hexo clean 、hexo g,查看public文件夹，里面多了一个atom.xml文件夹表示成功。 添加sitemap$ npm install hexo-generator-sitemap --save hexo clean 、hexo g,查看public文件夹，可以看到sitemap.xml文件。 sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。 添加本站访问次数在themes/yilia/layout/_partial 下找到footer.ejs , 在里面加入以下代码： &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; 文章模板打开hexo/scaffolds/post.md , 可以看到： --- title: {{ title }} date: {{ date }} tags: --- 做以下的修改，每次自动生成目录： --- title: {{ title }} date: {{ date }} tags: toc: true ---","tags":[{"name":"hexo+github","slug":"hexo-github","permalink":"http://yoursite.com/tags/hexo-github/"}]},{"title":"JS几道小题","date":"2017-07-07T12:16:39.462Z","path":"2017/07/07/js几道小题/","text":"2017.7.6日厦门实训js作业例题1：定义两个整数变量，交换两个变量的值 &lt;script&gt; var a = prompt(&quot;请输入a的值&quot;); var b = prompt(&quot;请输入b的值&quot;); var t; t = a; //t=2 a = b; //a=3 b = t; //b=2 alert(&quot;交换后a的值：&quot; + a + &quot;,交换后b的值：&quot; + b); &lt;/script&gt; 例题２：定义三个整数变量，输出一次最大值&lt;script type=&quot;text/javascript&quot;&gt; var a = prompt(&quot;输入第一个数&quot;); var b = prompt(&quot;输入第二个数&quot;); var c = prompt(&quot;输入第三个数&quot;); var max; if(a&gt;=b){ max = a; } else { max = b; } if(max&lt;c){ max = c; } alert(&quot;最大的值是：&quot; + max); &lt;/script&gt; 例题3：输入三个数从小到大的输出&lt;script&gt; var a = prompt(&quot;输入第一个数&quot;); var b = prompt(&quot;输入第二个数&quot;); var c = prompt(&quot;输入第三个数&quot;); var min,max,mid; if(a&gt;=b){ if(b&gt;=c){ max = a;mid = b;min = c; } else{ max = a;mid = c;min = b; } } else{ //a&lt;b if(b&gt;=c){ max = b;mid = a;min = c; } else{ max = b;mid = c;min = a; } } if(max&lt;c){ if(a&gt;=b){ max = c;mid = a;min = b; } else{ max = c;mid = b;min = a; } } alert(&quot;从小到大排序：&quot; + min + &quot;&lt;&quot; + mid + &quot;&lt;&quot; + max); &lt;/script&gt; 额….这个写的不是很好，傻瓜式…以后再说 例题4：定义整数的成绩变量，按区间输出等级:&lt;script&gt; var score = prompt(&quot;输入成绩：&quot;); var sco = parseInt(score / 10); switch(sco){ case 0 : alert(&quot;不及格！&quot;); break; case 1 : alert(&quot;不及格！&quot;); break; case 2 : alert(&quot;不及格！&quot;); break; case 3 : alert(&quot;不及格！&quot;); break; case 4 : alert(&quot;不及格！&quot;); break; case 5 : alert(&quot;不及格！&quot;); break; case 6: alert(&quot;D&quot;); break; case 7: alert(&quot;C&quot;); break; case 8: alert(&quot;B&quot;); break; case 9: alert(&quot;A&quot;); break; case 10: alert(&quot;A&quot;); break; default: alert(&quot;输入有误！&quot;); break; } &lt;/script&gt; 例题5：定义一个变量表示年份，判断是否是闰年&lt;script&gt; &lt;!--闰年的条件是:能被4整除,但是不能被100整除,或者能被四百整除--&gt; var year = prompt(&quot;输入一个年份：&quot;); if((year%4==0) &amp;&amp; (year%100!==0) || (year%400==0)) { alert(year+&quot;年是闰年&quot;); } else { alert(year+&quot;年是平年&quot;); } &lt;/script&gt; 例题6：输出100以内的质数&lt;script&gt; //2,3,5,7,11,13,17,19,23... //只能被1和自己本身除 for(var n=2;n&lt;=100;n++){ for(var m=2;m&lt;n;m++){ if(n%m == 0){ break; //跳出当前循环 } } if(m&gt;=n){ document.write( n + &quot;,&quot;); } } &lt;/script&gt; 2017.7.7日厦门实训js作业 –循环语句例题1：输出乘法口诀表&lt;script&gt; var num; for(var i=1;i&lt;10;i++){ for(var j=1;j&lt;10;j++){ if(j&gt;i){ break; } else { num = i*j; document.write(j + &quot;*&quot; + i + &quot;=&quot; + num + &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;); } } document.write(&quot;&lt;br/&gt;&quot;); } &lt;/script&gt; 例题2：输出10行10列表格&lt;button id=&quot;btn&quot;&gt;1.点击出现表格&lt;/button&gt; &lt;table id=&quot;table&quot; cellspacing=&quot;0&quot; cellpadding=&quot;10&quot; border=&quot;1&quot;&gt;&lt;/table&gt; &lt;script&gt; window.onload = function() { var btn = document.getElementById(&quot;btn&quot;); btn.onclick = out; function out(){ var table = document.getElementById(&quot;table&quot;); for(var j=1;j&lt;=10;j++){ var tr = document.createElement(&quot;tr&quot;); for(var i=1;i&lt;=10;i++){ var td = document.createElement(&quot;td&quot;); //创建元素节点eleNode td.innerHTML = i; tr.appendChild(td); //将元素节点td添加到tr中 } table.appendChild(tr); } } &lt;/script&gt; 自己在作业的基础上拓展了一下：获取任意行列的表格并输出 请输入行数：&lt;input id=&quot;rows&quot; /&gt;&lt;br/&gt;&lt;br/&gt; 请输入列数：&lt;input id=&quot;cols&quot; /&gt;&lt;br/&gt;&lt;br/&gt; &lt;button id=&quot;btn1&quot;&gt;2.点击出现你输入的表格&lt;/button&gt;&lt;br&gt;&lt;br/&gt; &lt;table id=&quot;table1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;10&quot; border=&quot;1&quot;&gt;&lt;/table&gt; &lt;script&gt; var btn1 = document.getElementById(&quot;btn1&quot;); btn1.onclick = out1; function out1(){ var table1 = document.getElementById(&quot;table1&quot;); var rows = document.getElementById(&quot;rows&quot;).value; var cols = document.getElementById(&quot;cols&quot;).value; for(var j=1;j&lt;=cols;j++){ var tr1 = document.createElement(&quot;tr&quot;); for(var i=1;i&lt;=rows;i++){ var td1 = document.createElement(&quot;td&quot;); td1.innerHTML = i; tr1.appendChild(td1); } table1.appendChild(tr1); } } &lt;/script&gt; 例题3：在上例表格中改变奇数行的背景&lt;button id=&quot;btn&quot;&gt;点击后奇数行有背景颜色&lt;/button&gt; &lt;table id=&quot;table&quot; border=&quot;1&quot; cellpadding=&quot;10px&quot; cellspacing=&quot;0&quot;&gt;&lt;/table&gt; &lt;script&gt; window.onload = function () { var btn = document.getElementById(&quot;btn&quot;); btn.onclick = out2; function out2() { var table = document.getElementById(&quot;table&quot;); for (var j = 1; j &lt;= 10; j++) { var tr = document.createElement(&quot;tr&quot;); if (j%2 != 0) { //判断是否为奇数行 tr.style.backgroundColor = &quot;red&quot;; } for (var i = 1; i &lt;= 10; i++) { var td = document.createElement(&quot;td&quot;); td.innerHTML = i; tr.appendChild(td); } table.appendChild(tr); } } } &lt;/script&gt; 例题4：输出序列1,1,2,3,5,8,13…… N个数&lt;script&gt; var a=1;b=1; if(a=1){ document.write(a + &quot; &quot;); } if(b=1){ document.write(b + &quot; &quot;); } for(var n=0;n&lt;500;n++){ n = a + b; //1+1=2 ;n=2 n=3 n=5 a = b; //a=1; a=1; a=2; a=3; b = n; //b=1 b=2; b=3; b=5; document.write(n + &quot; &quot;); } &lt;/script&gt; 此段代码不够完善…待完善 2017.7.10日厦门实训js作业例题1：动态的显示当前时间function startTime(){ var today = new Date(); var year = today.getFullYear(); var month = today.getMonth() + 1; var day = today.getDate(); var h = today.getHours(); var m = today.getMinutes(); var s = today.getSeconds(); m = checkTime(m); s = checkTime(s); document.getElementById(&quot;time&quot;).innerHTML =&quot;现在是北京时间：&quot; + year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot; + &quot; &quot; + h + &quot;:&quot; + m + &quot;:&quot; + s ; t = setTimeout(function(){startTime()},500); } function checkTime(i){ if(i&lt;10){ i = &quot;0&quot; + i; } return i; } &lt;body onload=&quot;startTime()&quot;&gt; &lt;div id=&quot;time&quot;&gt;&lt;/div&gt; &lt;/body&gt; 例题2：计算器实现加减乘除（最简单的）数字1：&lt;input id=&quot;num1&quot;&gt;&lt;br/&gt;&lt;br/&gt; 数字2：&lt;input id=&quot;num2&quot;&gt;&lt;br/&gt;&lt;br/&gt; &lt;button onclick=&quot;add()&quot;&gt;加法&lt;/button&gt; &lt;button onclick=&quot;del()&quot;&gt;减法&lt;/button&gt; &lt;button onclick=&quot;mul()&quot;&gt;乘法&lt;/button&gt; &lt;button onclick=&quot;division()&quot;&gt;除法&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; 结果为：&lt;input id=&quot;result&quot; value=&quot;&quot;&gt; &lt;script&gt; function add() { var num1 = document.getElementById(&quot;num1&quot;).value; var num2 = document.getElementById(&quot;num2&quot;).value; var result = parseFloat(num1) + parseFloat(num2); document.getElementById(&quot;result&quot;).value = result; } function del() { var num1 = document.getElementById(&quot;num1&quot;).value; var num2 = document.getElementById(&quot;num2&quot;).value; var result = parseFloat(num1) - parseFloat(num2); document.getElementById(&quot;result&quot;).value = result; } function mul() { var num1 = document.getElementById(&quot;num1&quot;).value; var num2 = document.getElementById(&quot;num2&quot;).value; var result = num1 * num2; document.getElementById(&quot;result&quot;).value = result; } function division() { var num1 = document.getElementById(&quot;num1&quot;).value; var num2 = document.getElementById(&quot;num2&quot;).value; var result = num1 / num2; document.getElementById(&quot;result&quot;).value = result; } &lt;/script&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"软件测试初学","date":"2017-05-24T15:12:30.000Z","path":"2017/05/24/软件测试初学/","text":"软件缺陷常见问题 统一性中英文问题 容错性互动性 用户输入信息有误时，按“确定”后，所有信息被清空(这种情况要避免) 对于所有的删除信息在删除之前都要给出是否删除确认的提示或者放弃的提示。 危险操作之前，提醒 改变数据状态，提醒 如填写资料有错误的时候，应该能够提示错误的位置，让用户知道到底是哪些地方输入的不正确 用户体验使用的提示信息要通俗易懂 兼容性： 操作系统版本 屏幕分辨率 网络类型(wifi,3G,4G) 易用性对于要求用户大量录入信息的页面，要支持Tab键的输入，Tab键的走向要一般要遵循从做左到右，从上到下的的原则 安全性： 登录网站进入其内部网页后，直接拷贝网址，然后粘贴到另一IE 窗口输入，在其他机器上看是否可以绕过登录直接访问 对于需要登录的系统，在用户不操作的一定时间内，出于安全性考虑，最好要让用户重新登录才能重新使用该系统 有些文件在ini等配置文件中写出了管理员口令密码等信息，而且是明文的!这是一个安全隐患 ！！！所有软件测试都是建立在业务之上的 等价类概念：是指把程序的输入域根据等价类原则划分成若干部分，然后从每个部分中选取少数具有代表性的数据作为测试输入数据的一种方法。 有效等价类 无效等价类 Junit单元测试测试用例不是用来证明你是对的，而是用来证明你没错。 入门：1.新建一个类： File → Java Project : name (JUnit_Test) → 在src下new Package : name (JunitTest) → new class : name (Calculator) → 敲代码： package JunitTest; public class Calculator { public int add(int a,int b){ return a+b; } public int subtract(int a,int b){ return a-b; } public int multiply(int a,int b){ return a*b; } public int divide(int a,int b){ return a/b; } } 2.导入JUnit jar包： JUnit_Test → Build Path → Add Libraries… → JUnit → Next&gt; → Finish 3.JunitTest → new : JUnit Test Case →输入测试工作区的名字 Name : (AddSubTest) , Class under test : name (Calculator) → Finish 4.运行测试用例： 右键 → Run AS → Junit Test → 结果显示，测试工作都运行通过 第一个测试用例：","tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"}]},{"title":"JS实现轮播图","date":"2017-01-31T08:10:42.000Z","path":"2017/01/31/JS实现轮播图/","text":"这个轮播图是在2016年12月完成的，是我用js完成的第一个小东西。 html代码实现&lt;div id=&quot;content&quot;&gt; &lt;div id=&quot;images&quot; style=&quot;left: -600px;&quot;&gt; &lt;img src=&quot;images/5.jpg&quot;&gt; &lt;img src=&quot;images/1.jpg&quot;&gt; &lt;img src=&quot;images/2.jpg&quot;&gt; &lt;img src=&quot;images/3.jpg&quot;&gt; &lt;img src=&quot;images/4.jpg&quot;&gt; &lt;img src=&quot;images/5.jpg&quot;&gt; &lt;img src=&quot;images/1.jpg&quot;&gt; &lt;/div&gt; &lt;div id=&quot;circle&quot;&gt; &lt;span class=&quot;on&quot; index=&quot;1&quot;&gt;&lt;/span&gt; &lt;span index=&quot;2&quot;&gt;&lt;/span&gt; &lt;span index=&quot;3&quot;&gt;&lt;/span&gt; &lt;span index=&quot;4&quot;&gt;&lt;/span&gt; &lt;span index=&quot;5&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;btn&quot; id=&quot;btn_l&quot;&gt;&amp;lt;&lt;/div&gt; &lt;div class=&quot;btn&quot; id=&quot;btn_r&quot;&gt;&amp;gt;&lt;/div&gt; &lt;/div&gt; css部分代码实现 1.”content” 处设置相对位置：position:relative; 图片展示为只显示一张图片，所以溢出content容器部分使用属性：overflow:hidden; 2.左、右按钮部分代码： position: relative; cursor: pointer; //鼠标移上去，显示手指妆 height: 50px; width: 30px; background: rgba(0,0,0,0.3); top: 50%; font-size: 40px; text-align: center; line-height: 50px; display: none; //当鼠标移上去时，btn出现 color: #fff; javascript部分代码实现点击&lt; &gt;按钮让图片左右移动function animate(offset){ var newLeft = parseInt(images.style.left) + offset; images.style.left = newLeft + &apos;px&apos;; if (newLeft&lt;-3000) { images.style.left = -600 + &apos;px&apos;; } if (newLeft&gt;-600) { images.style.left = -3000 + &apos;px&apos;; } } btn_l.onclick=function(){ animate(600); } btn_r.onclick=function(){ animate(-600); } if循环语句是实现图片无限循环； 这时，轮播图可以实现左右点击，图片相应变化的功能。 设置轮播图的定时器var timer; function play(){ timer = setInterval(function() { btn_r.onclick() },3000) //每3000ms图片自动移动 } play(); 使用setIntervel()设置定时器。 清除轮播图的定时器function stop() { clearInterval(timer); } content.onmouseover = stop; content.onmouseout = play; 图片自动移动时，当把鼠标悬停在content内时，图片暂停移动。 小圆点随图片变化相应变化function showCircle(){ for (var i=0;i&lt;circle.length;i++){ if(circle[i].className==&apos;on&apos;){ circle[i].className=&apos;&apos;; } } circle[index-1].className=&apos;on&apos;; } for循环用来清除之前circle的样式； 这时，点击&lt; &gt; 按钮小圆点会随图片相应点亮。 for (var i=0;i&lt;circle.length;i++){ circle[i].onclick=function(){ var clickIndex=parseInt(this.getAttribute(&apos;index&apos;)); var offset=600*(index-clickIndex); animate(offset); index=clickIndex; showCircle(); } } 利用getAttribute(‘’)获取自定义index，之后 btn_l.onclick=function(){ index -= 1; if(index&lt;1){ index=5; } showCircle(); animate(600); } btn_r.onclick=function(){ index += 1; if(index&gt;5){ index=1; } showCircle(); animate(-600); }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"用github+hexo搭建博客","date":"2017-01-30T14:44:59.000Z","path":"2017/01/30/用github-hexo搭建博客/","text":"2016年月底第一次正式开始搭建博客，在学长和另一个小伙伴的帮助下，我初次认识github+hexo，被它给吸引。寒假开始后，就在准备换主题，因为我对原始主题实在无爱，强迫症越来越严重的我，不换好主题坚持不做笔记（无奈脸）。刚刚换好主题的我，觉得之前自己用了好几个晚上都没有换好主题的自己简直是傻bi（给自己一个黑人问号），不过好在自己现在换好了主题，赶紧做笔记，谨防自己忘了。 清除，生成，部署123$ hexo clean or(hexo c)$ hexo generate$ hexo deploy 谨记：每次更改了一些信息后都要用这三步进行部署 安装yilia主题1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 安装好后，在_config.yml下修改theme：landscape为theme：yilia 写文章 找到blog ☞ sources ☞ _post ☞ 写博客 博客开头格式(以下为例子)：title: xxxdata: xxxx-xx-xxtags: xxxx 如果文章较长，如果全都在主页显示，就会很累赘，浏览也不是很方便，那么就可以在每篇文章中加入&lt;!--more--&gt; 文章写好直接执行下面命令即可直接发布文章$ hexo d -g 注意1.常用命令： hexo new “post name” （新建文章） hexo help （查看帮助） hexo version （查看hexo的版本） 2.Markdown语法参考链接： 链接 ● Hexo主题Yilia","tags":[{"name":"hexo+github","slug":"hexo-github","permalink":"http://yoursite.com/tags/hexo-github/"}]},{"title":"Hello World","date":"2016-12-27T10:23:59.706Z","path":"2016/12/27/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo+github","slug":"hexo-github","permalink":"http://yoursite.com/tags/hexo-github/"}]}]