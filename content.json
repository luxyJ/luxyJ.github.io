[{"title":"正则表达式（二）","date":"2018-02-22T13:31:34.000Z","path":"2018/02/22/正则表达式（二）/","text":"学习正则表达式三十分钟入门~ 常用元字符 代码 说明 备注 . 匹配除换行符以外的任意字符 \\b 匹配单词的开始或结束 匹配一个位置 \\d 匹配一位数字 代表数量 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 ^ 匹配字符串的开始 匹配一个位置 \\bhi\\b : 精确查找hi这个单词 \\bhi\\b.*\\bLucy\\b : 先是一个单词hi，然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词 0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d = 0\\d{2}-\\d{8} : 以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字 \\ba\\w*\\b : 以字母a开头的单词（先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w*)，最后是单词结束处(\\b)） \\d+ : 匹配1个或更多连续的数字 \\b\\w{6}\\b : 匹配刚好6个字符的单词 ^\\d{5,12}$ : 必须是5到12个数字（网站如果要求你填写的QQ号必须为5位到12位数字时） 常用限定符 代码/语法 说明 * 重复0次或更多次 + 重复1次或更多次 ? 重复0次或1次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 Windows\\d+: 匹配Windows后面跟1个或更多数字 ^\\w+ : 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) [aeiou] : 匹配任意一个英文元音字母 [.?!] : 匹配标点符号（.或?或!） [0-9] = \\d : 一位数字 [a-z0-9A-Z] = \\w : （如果只考虑英文的话） 常用的反义代码 代码/语法 说明 \\W 匹配任意不是字母,数字,下划线,汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 常用分组语法 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?\\exp) 匹配exp,并捕获文本到名称为name的组里,也可以写成(?’name’exp) (?:exp) 匹配exp,不捕获匹配的文本,也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 提供注释让人阅读 零宽断言(?=exp) 也叫做零宽度正预测先行断言：比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。 (?&lt;=exp) 也叫做零宽度正回顾后发断言：比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 负向零宽断言(?!exp) 也叫做零宽度负预测先行断言：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。 (?&lt;!exp) 也叫做零宽度负回顾后发断言：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字 懒惰限定符 代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 贪婪匹配：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。 懒惰匹配：a.*?b，匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。 字符转义 deerchao\\.net : 匹配deerchao.net C:\\\\Windows : 匹配C:\\Windows 正则表达式三十分钟入门教程","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"学习Mongoose","date":"2018-01-18T15:09:13.000Z","path":"2018/01/18/学习Mongoose/","text":"Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具。 mongoose入门安装与连接安装mongoose:1npm install mongoose --save 创建一个db.js:1234567891011121314151617181920212223var mongoose = require('mongoose');var dbUrl = 'mongodb://101.132.128.72:27017/myblog';mongoose.connect(dbUrl, &#123; useMongoClient: true&#125;);// 连接成功mongoose.connection.on('connected', function () &#123; console.log('数据库连接成功'); &#125;); // 连接异常mongoose.connection.on('error',function (err) &#123; console.log('数据库连接异常' + err); &#125;); // 连接断开mongoose.connection.on('disconnected', function () &#123; console.log('数据库断开了'); &#125;); module.exports = mongoose; SchemaSchema是mongoose里会用到的一种数据模式，可以理解为表结构的定义。每个Schema会映射到mongodb中的一个Connection，他不具备操作数据库的能力。 12# 在db.js中增加以下代码：module.exports = mongoose; 下面定义一个user的Schema，命名user.js:123456789var mongoose = require('./db.js');var Schema = mongoose.Schema;var UserSchema = new Schema(&#123; username: &#123; type: String &#125;, password: &#123; type: String &#125;, age: &#123; type: Number &#125;, logindata: &#123; type: Date &#125;&#125;); Model定义好了Schema，接下来就是生成Model。model是由Schema生成的模型，可以对数据库进行操作。 我们对上面的定义的user的schema生成一个User的model并导出，在user.js中增加以下代码：1module.exports = mongoose.model('User', UserSchema); 常用数据库操作插入(save)","tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"Linux下MongoDB的安装和启动","date":"2018-01-05T02:01:27.000Z","path":"2018/01/05/Linux下MongoDB的安装和启动/","text":"MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 MongoDB的安装下载安装包1234# 下载curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.2.9.tgz# 解压缩tar zxvf mongodb-linux-x86_64-3.2.9.tgz 创建数据库文件夹、日志文件和配置文件123mkdir -p /usr/local/server/mongodb/datatouch /usr/local/server/mongodb/mongod.logtouch /usr/local/server/mongodb/mongodb.conf 将下载好的mongodb移动到新建的文件夹下：1mv mongodb-linux-x86_64-3.2.9/* /usr/local/server/mongodb/ 查看123456789[root@izuf6alst6rugagpxl8wizz /]# cd /usr/local/server/mongodb[root@izuf6alst6rugagpxl8wizz mongodb]# lsbin GNU-AGPL-3.0 mongodb.conf mongod.log READMEdata mongod mongodb.log MPL-2 THIRD-PARTY-NOTICES[root@izuf6alst6rugagpxl8wizz mongodb]# cd bin[root@izuf6alst6rugagpxl8wizz bin]# lsbsondump mongod mongoexport mongoimport mongoperf mongos mongotopmongo mongodump mongofiles mongooplog mongorestore mongostat bin下的mongod就是MongoDB的服务进程，mongo就是其客户端。 启动MongoDB在MongoDB安装目录下的bin下使用mongod启动MongoDB:12[root@izuf6alst6rugagpxl8wizz bin]# ./mongod --dbpath=/usr/local/server/mongodb/data --logpath=/usrerver/mongodb/mongod.log --logappend&amp;[1] 1090 之后，我们通过查看端口号看MongoDB是否启动了(下面这样就说明启动成功)：1234[root@izuf6alst6rugagpxl8wizz bin]# cd ../data[root@izuf6alst6rugagpxl8wizz data]# netstat -lanp | grep \"27017\"tcp 0 0 0.0.0.0:27017 0.0.0.0:* LISTEN 1090/./mongod unix 2 [ ACC ] STREAM LISTENING 15433 1090/./mongod /tmp/mongodb-27017 成功之后，我们使用mongo客户端访问一下该数据库:12345[root@izuf6alst6rugagpxl8wizz bin]# ./mongoMongoDB shell version: 3.2.9connecting to: test........&gt; 这样就说明我已经安装成功了！ 开机自启上面的操作是我们手动启动MongoDB，为了让他每次开机自启，我们需要编辑/etc/rc.local123[root@izuf6alst6rugagpxl8wizz bin]# vim /etc/rc.local#add mongonDB service rm -rf /usr/local/server/mongodb/data/* &amp;&amp; /usr/local/server/mongodb/bin/mongod --dbpath=/usr/local/server/mongodb/data/ --logpath=/usr/local/server/mongodb/mongod.log --logappend&amp; 到这里之后我们重启计算机，再次使用mongo命令，发现他是可以成功的。 但是每次使用mongo命令登录MongDB还要转到目录/usr/local/server/mongodb/bin下再执行./mongo实在是太麻烦了，所以执行以下命令，在任何目录下都可以使用命令mongo了： 12345678[root@izuf6alst6rugagpxl8wizz bin]# cp mongo /usr/bin/cp: overwrite ‘/usr/bin/mongo’? yes[root@izuf6alst6rugagpxl8wizz bin]# cd /[root@izuf6alst6rugagpxl8wizz /]# mongoMongoDB shell version: 3.2.9connecting to: test........&gt; 帮助： (linux公社)[http://www.linuxidc.com/Linux/2011-05/36309.htm] (CSDN)[http://blog.csdn.net/wlzx120/article/details/52301799]","tags":[]},{"title":"学习linux之Docker","date":"2017-12-07T06:43:19.000Z","path":"2017/12/07/学习linux之Docker/","text":"Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。 ubuntu安装我这里学习的docker，是在ubuntu下使用的，对于ubuntu安装中的一些问题记录在这里。 ubuntu镜像文件下载地址 安装时，选择其他选项（即可以自己创建、调整分区）；继而出现安装类型，自己进行分区： 在这个过程中，我发现自己的界面不能完全显示（有一部分挡在下面，怎么拉都看不到），解决办法很简单：按键Alt+F7就可以拖动看到下面的内容。 自适应客户机操作方法见网址：解决屏幕太小问题 安装好后，点击最上方– 查看 –&gt; 立即适应客户机 安装和使用docker安装之前，我们首先确保自己的linux系统内核版本高于3.10，并且系统是64位:12[root@izuf6alst6rugagpxl8wizz ~]# uname -ir3.10.0-514.26.2.el7.x86_64 x86_64 在root下安装docker，使用命令(下面的运行结果是我第二次运行的结果，docker安装完成):12345[root@izuf6alst6rugagpxl8wizz ~]# sudo yum -y install dockerLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfilePackage 2:docker-1.12.6-68.gitec8512b.el7.centos.x86_64 already installed and latest versionNothing to do 接下来，启动Docker后台服务：12[root@izuf6alst6rugagpxl8wizz ~]# sudo service docker startRedirecting to /bin/systemctl start docker.service 下一步，测试运行hello-world,如果本地没有hello-world这个镜像，就会下载一个hello-world的镜像，并在容器内运行：1[root@izuf6alst6rugagpxl8wizz ~]# sudo docker run hello-world 交互式容器进入交互式容器，使用命令docker run -i -t ubuntu /bin/bash123456789# 启动容器root@luyaj-virtual-machine:/home/luyaj# docker run -i -t ubuntu /bin/bashroot@1ed36419aeb9:/# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 01:23 ? 00:00:00 /bin/bashroot 9 1 0 01:25 ? 00:00:00 ps -efroot@1ed36419aeb9:/# exitexitroot@luyaj-virtual-machine:/home/luyaj# 查看容器:docker ps [-a][-l] &amp;&amp; docker inspect [id] 12345678910111213141516171819202122232425262728293031323334# 显示进程root@luyaj-virtual-machine:/home/luyaj# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESroot@luyaj-virtual-machine:/home/luyaj# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1ed36419aeb9 ubuntu \"/bin/bash\" 3 minutes ago Exited (0) About a minute ago practical_swansonb934d23e6789 ubuntu \"echo luya\" 11 minutes ago Exited (0) 11 minutes ago kind_hawking9e7de9e1f31b ubuntu \"echo hello\" 13 minutes ago Exited (0) 13 minutes ago peaceful_kowalevski# 显示配置信息root@luyaj-virtual-machine:/home/luyaj# docker inspect 9e7de9e1f31b [ &#123; \"Id\": \"9e7de9e1f31b4d63573b5dd962c23914085566a3c24fc55550027dd459d82036\", \"Created\": \"2017-12-12T01:13:35.811132019Z\", \"Path\": \"echo\", \"Args\": [ \"hello\" ], \"State\": &#123; \"Status\": \"exited\", \"Running\": false, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 0, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2017-12-12T01:13:38.847825304Z\", \"FinishedAt\": \"2017-12-12T01:13:38.893957073Z\" &#125; &#125;] 自定义容器名docker run --name=自定义名 -i -t IMAGE /bin/bash 123456789101112131415# 自定义容器名root@luyaj-virtual-machine:/home/luyaj# docker run --name=container2 -i -t ubuntu /bin/bashroot@9ec00bfc984d:/# exitexit# 查看当前容器进程root@luyaj-virtual-machine:/home/luyaj# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9ec00bfc984d ubuntu \"/bin/bash\" 25 seconds ago Exited (0) 9 seconds ago container21ed36419aeb9 ubuntu \"/bin/bash\" 10 hours ago Exited (0) 10 hours ago practical_swansonb934d23e6789 ubuntu \"echo luya\" 10 hours ago Exited (0) 10 hours ago kind_hawking9e7de9e1f31b ubuntu \"echo hello\" 10 hours ago Exited (0) 10 hours ago peaceful_kowalevski# 显示配置信息root@luyaj-virtual-machine:/home/luyaj# docker inspect container2 重新启动停止的容器docker start [-i] 容器名 12345678910# 重新启动容器root@luyaj-virtual-machine:/home/luyaj# docker start -i container2root@9ec00bfc984d:/# exitexitroot@luyaj-virtual-machine:/home/luyaj# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9ec00bfc984d ubuntu \"/bin/bash\" 5 minutes ago Exited (0) 10 seconds ago container21ed36419aeb9 ubuntu \"/bin/bash\" 10 hours ago Exited (0) 10 hours ago practical_swansonb934d23e6789 ubuntu \"echo luya\" 10 hours ago Exited (0) 10 hours ago kind_hawking9e7de9e1f31b ubuntu \"echo hello\" 10 hours ago Exited (0) 10 hours ago peaceful_kowalevski 删除停止的容器删除停止的容器：docker rm 容器名。（只能删除已经停止的容器，不能删除运行中的容器） 1234567root@luyaj-virtual-machine:/home/luyaj# docker rm container2container2root@luyaj-virtual-machine:/home/luyaj# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1ed36419aeb9 ubuntu \"/bin/bash\" 10 hours ago Exited (0) 10 hours ago practical_swansonb934d23e6789 ubuntu \"echo luya\" 10 hours ago Exited (0) 10 hours ago kind_hawking9e7de9e1f31b ubuntu \"echo hello\" 10 hours ago Exited (0) 10 hours ago peaceful_kowalevski 守护式容器以守护形式运行容器命令：docker run -i -t IMAGE /bin/bash，接下来使用Ctrl+P, Ctrl+Q。 12345678910root@luyaj-virtual-machine:/home/luyaj# docker run -i -t ubuntu /bin/bash# Ctrl+P、Ctrl+Q（转到后台）, 换行root@d7f3a54f0db4:/# root@luyaj-virtual-machine:/home/luyaj# # 可以查看到这几个容器当前还在运行root@luyaj-virtual-machine:/home/luyaj# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd7f3a54f0db4 ubuntu \"/bin/bash\" About a minute ago Up About a minute affectionate_beaver5e724ab47af5 ubuntu \"/bin/bash\" 4 minutes ago Up 4 minutes amazing_franklin 附加到运行中的容器命令：docker attach 容器名. 1234567891011121314151617181920root@luyaj-virtual-machine:/home/luyaj# docker attach d7f3a54f0db4 root@d7f3a54f0db4:/# root@luyaj-virtual-machine:/home/luyaj# # 可以看到有两个容器在运行root@luyaj-virtual-machine:/home/luyaj# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd7f3a54f0db4 ubuntu \"/bin/bash\" 6 minutes ago Up 6 minutes affectionate_beaver5e724ab47af5 ubuntu \"/bin/bash\" 10 minutes ago Up 10 minutes amazing_franklin# 进入此命令root@luyaj-virtual-machine:/home/luyaj# docker attach d7f3a54f0db4 # 退出root@d7f3a54f0db4:/# exitexit# 可以看到上面的容器停止了root@luyaj-virtual-machine:/home/luyaj# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES5e724ab47af5 ubuntu \"/bin/bash\" 11 minutes ago Up 11 minutes amazing_franklin 停止守护式容器发送一个信号，等待停止：docker stop 容器名直接杀死：docker kill 容器名 在容器中使用Nginx部署静态网站Nginx部署流程如下： 创建映射80端口的交互式容器 安装Nginx 安装文本编辑器vim 创建静态页面 修改Nginx配置文件 运行Nginx 12345678910111213141516171819202122232425262728# 创建带端口映射的交互容器，命名为\"web\"，使用ubuntu为系统。root@luyaj-virtual-machine:/home/luyaj# docker run -p 80 --name web1 -i -t ubuntu /bin/bash# 更新包root@416f6aee01e7:/# apt-get update# 安装Nginxroot@416f6aee01e7:/# apt install -y nginx# 安装vimroot@416f6aee01e7:/# apt intall -y vim# 创建静态页面（在index.html中填写前端代码）root@fa38c10136a0:/# mkdir -p /var/www/htmlroot@fa38c10136a0:/# cd /var/www/htmlroot@fa38c10136a0:/var/www/html# vim index.html# 使用whereis查看nginx在哪root@f3cfa277a97e:/var/www/html# whereis nginxnginx: /usr/sbin/nginx /etc/nginx /usr/share/nginx# 打开文件defaultroot@f3cfa277a97e:/var/www/html# ls /etc/nginxconf.d fastcgi_params koi-win nginx.conf scgi_params sites-enabled uwsgi_paramsfastcgi.conf koi-utf mime.types proxy_params sites-available snippets win-utfroot@f3cfa277a97e:/var/www/html# ls /etc/nginx/sites-enabled defaultroot@f3cfa277a97e:/var/www/html# vim /etc/nginx/sites-enabled/default 在default文件，将root值修改为我们创建的静态网站的位置（/var/www/html）,操作如图: 123456789101112131415161718192021222324252627282930# 切换到根目录，运行nginx，使用ps命令在容器查中看当前的进程root@f3cfa277a97e:/var/www/html# cd /root@f3cfa277a97e:/# nginxroot@f3cfa277a97e:/# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 12:53 ? 00:00:00 bashroot 18 1 0 13:08 ? 00:00:00 nginx: master process nginxwww-data 19 18 0 13:08 ? 00:00:00 nginx: worker processroot 20 1 0 13:09 ? 00:00:00 ps -ef# Ctrl+P,Ctrl+Q. “docker ps”或“docker port 容器名”可以看到容器映射的端口root@f3cfa277a97e:/# [root@izuf6alst6rugagpxl8wizz ~]# [root@izuf6alst6rugagpxl8wizz ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0e10487869ea ubuntu \"/bin/bash\" 30 minutes ago Up 30 minutes silly_bosef3cfa277a97e ubuntu \"bash\" 35 hours ago Up 17 minutes 0.0.0.0:32769-&gt;80/tcp web18f8c5c20e073 ubuntu \"bash\" 35 hours ago Up 35 hours nostalgic_davinci[root@izuf6alst6rugagpxl8wizz ~]# docker port web180/tcp -&gt; 0.0.0.0:32769# 运行[root@izuf6alst6rugagpxl8wizz ~]# curl http://127.0.0.1:32769&lt;html&gt;&lt;head&gt; &lt;title&gt;nginx in docker&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello, first website in docker!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，出现了我们编辑的页面。我们也可以在浏览器中访问页面。由于我这里是在云服务器上开启的容器，所以使用云服务器的ip地址+端口号，即可成功访问页面。 上面我们是用宿主机的ip地址来查看的网页，这里我们还可以用容器的ip地址查看页面：1[root@izuf6alst6rugagpxl8wizz ~]# docker inspect web1 运行结果如下，找到ip地址（不需要指定端口号，默认为80端口）： 到这里我们就完成了一个静态页面！下面来看看怎么运行nginx。 123456789101112131415161718192021222324252627282930313233# 停用容器[root@izuf6alst6rugagpxl8wizz ~]# docker stop web1web1# 开启容器[root@izuf6alst6rugagpxl8wizz ~]# docker start -i web1# 可以看到nginx没有开启root@f3cfa277a97e:/# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 14:19 ? 00:00:00 bashroot 9 1 0 14:20 ? 00:00:00 ps -ef# exec命令启动nginx，查看root@f3cfa277a97e:/# [root@izuf6alst6rugagpxl8wizz ~]# [root@izuf6alst6rugagpxl8wizz ~]# docker exec web1 nginx[root@izuf6alst6rugagpxl8wizz ~]# docker top web1UID PID PPID C STIME TTY TIME CMDroot 12250 12227 0 22:19 pts/2 00:00:00 bashroot 12370 1 0 22:20 ? 00:00:00 nginx: master process nginx33 12371 12370 0 22:20 ? 00:00:00 nginx: worker process# 运行网站（会发现有问题），使用inspect查看容器，重新输入地址，就成功了。[root@izuf6alst6rugagpxl8wizz ~]# http://172.17.0.3-bash: http://172.17.0.3: No such file or directory[root@izuf6alst6rugagpxl8wizz ~]# docker inspect/usr/bin/docker-current: \"inspect\" requires a minimum of 1 argument.See '/usr/bin/docker-current inspect --help'.Usage: docker inspect [OPTIONS] CONTAINER|IMAGE|TASK [CONTAINER|IMAGE|TASK...]Return low-level information on a container, image or task[root@izuf6alst6rugagpxl8wizz ~]# docker inspect web1 友情链接：docker上手并部署Ngnix 构建镜像","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"《指尖上行》移动前端开发之路","date":"2017-11-29T12:50:43.000Z","path":"2017/11/29/《指尖上行》移动前端开发之路/","text":"本书从基础的移动页面布局和常见前端框架，到进阶的移动页面动画技术、Web API及性能优化，再到各类实战案例剖析等，讲解了技术层面的各类知识和心得。另外，书中还介绍了常用的数据分析方法，以验证项目效果。 移动页面开发设备像素设备像素有两个： 物理像素：指设备显示屏中使用的最小显示单元，即屏幕分辨率（如：iphone5的屏幕分辨率是640像素*1136像素） 独立像素：指Web编程中的逻辑像素，即CSS像素（如：iphone5的CSS像素是320像素*568像素） 像素密度(PPI)PPI(Pixels Per Inch)是用来表示设备每英寸所拥有的物理像素数目。这个数值越高，屏幕越清晰。公式如下：PPI = (sqrt(屏幕分辨率宽^2+屏幕分辨率高^2))/4; 当显示屏的PPI超过了某一数值时，人的肉眼就无法分辨其中的单独像素，这就是Retina显示屏。 设备像素比(DPR)DPR(Device Pixel Ratio)是指物理像素和CSS像素的比例。 对于常规屏来说，物理像素和CSS像素的比值是1:1，但是在Retina屏幕设备中，一个CSS像素可能等于多个物理像素。（iphone从4代开始DPR基本为2，plus除外） 设置ViewportViewport有三种：Layout Viewport, Visual Viewport, Ideal Viewport(理想的). 为了将浏览器默认的Layout Viewport宽度设置为Ideal Viewport的宽度，在开发移动页面时一般都会在head标签中写入以下代码：1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 总结： 关于设备像素、设备密度及设备像素比","tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"}]},{"title":"学习linux之第二篇","date":"2017-11-02T10:35:28.000Z","path":"2017/11/02/学习linux之第二篇/","text":"这是linux后半部分的学习，记录RPM包以及shell，正则表达式等内容。 安装rpm包及源码包RPM(RedHat Package Manager)工具RPM是以一种数据库记录的方式来将我们需要的套件安装到linux主机的一套管理程序。 1234567891011121314151617[root@localhost jly]# mount /dev/cdrom /mnt/mount: /dev/sr0 写保护，将以只读方式挂载[root@localhost jly]# ls /mnt/CentOS_BuildTag GPL LiveOS RPM-GPG-KEY-CentOS-7EFI images Packages RPM-GPG-KEY-CentOS-Testing-7EULA isolinux repodata TRANS.TBL[root@localhost jly]# ls /mnt/Packages/|head389-ds-base-1.3.5.10-11.el7.x86_64.rpm389-ds-base-libs-1.3.5.10-11.el7.x86_64.rpmabattis-cantarell-fonts-0.0.16-3.el7.noarch.rpmabrt-2.1.11-45.el7.centos.x86_64.rpmabrt-addon-ccpp-2.1.11-45.el7.centos.x86_64.rpmabrt-addon-kerneloops-2.1.11-45.el7.centos.x86_64.rpmabrt-addon-pstoreoops-2.1.11-45.el7.centos.x86_64.rpmabrt-addon-python-2.1.11-45.el7.centos.x86_64.rpmabrt-addon-vmcore-2.1.11-45.el7.centos.x86_64.rpmabrt-addon-xorg-2.1.11-45.el7.centos.x86_64.rpm 安装和升级一个rpm包12345678910111213141516171819[root@localhost jly]# rpm -ivh /mnt/Packages/abattis-cantarell-fonts-0.0.16-3.el7.noarch.rpm 准备中... ################################# [100%] 软件包 abattis-cantarell-fonts-0.0.16-3.el7.noarch 已经安装# 升级包(-U表示升级)[root@localhost jly]# rpm -Uvh /mnt/Packages/abattis-cantarell-fonts-0.0.16-3.el7.noarch.rpm # 卸载包[root@localhost jly]# rpm -e /mnt/Packages/# 查询一个包是否已安装[root@localhost jly]# rpm -q abattis-cantarell-fontsabattis-cantarell-fonts-0.0.16-3.el7.noarch# 查询当前系统已安装的rpm包root@localhost jly]# rpm -qa# 得到一个已安装的rpm包的相关信息[root@localhost jly]# rpm -qi abattis-cantarell-fonts -i:表示安装 -v:表示可视化 -h:表示显示安装进度 另外在安装rpm包时，常用的附带参数还包括：--force:表示强制安装，即使覆盖属于其他包的文件也要安装。--nodeps:表示当要安装的rpm包依赖于其他包时，即使其他包没有安装，也要安装这个包。 yum工具1234567891011121314151617181920212223242526272829# 列出所有可用rpm包[root@localhost jly]# yum list# 搜索一个包[root@localhost jly]# yum search vim已加载插件：fastestmirror, langpacksRepodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fastLoading mirror speeds from cached hostfile * base: centos.ustc.edu.cn * extras: centos.ustc.edu.cn * updates: centos.ustc.edu.cn================================================================================================ N/S matched: vim =================================================================================================protobuf-vim.x86_64 : Vim syntax highlighting for Google Protocol Buffers descriptionsvim-X11.x86_64 : The VIM version of the vi editor for the X Window Systemvim-common.x86_64 : The common files needed by any version of the VIM editorvim-enhanced.x86_64 : A version of the VIM editor which includes recent enhancementsvim-filesystem.x86_64 : VIM filesystem layoutvim-minimal.x86_64 : A minimal version of the VIM editor 名称和简介匹配 only，使用“search all”试试。# 安装一个rpm包（不加-y选项会以与用户交互的方式安装）[root@localhost jly]# yum install [-y] [rpm包名]# 卸载一个rpm包[root@localhost jly]# yum remove [-y] [rpm包名]# 升级一个rpm包[root@localhost jly]# yum update [-y] [rpm包名] Shell基础知识shell是系统跟计算机硬件交互时使用的中间介质，它只是系统的一个工具。如果把计算机硬件比作一个人的躯体，那系统内核就是人的大脑，shell称为人的五官更为贴切。 一些命令记录历史命令 !!:表示执行上一条指令。 !n:表示执行命令历史中的第n条指令。 123456789101112[root@localhost jly]# pwd/home/jly[root@localhost jly]# !!pwd/home/jly[root@localhost jly]# history |grep 25 25 exit 34 history |grep 25[root@localhost jly]# !25exitexit 别名使用alias命令把一个常用的且很长的指令别名为一个简单易记得指令；unalias解除别名功能。1234567891011121314151617[root@localhost jly]# aliasalias cp='cp -i'alias egrep='egrep --color=auto'alias fgrep='fgrep --color=auto'alias grep='grep --color=auto'alias l.='ls -d .* --color=auto'alias ll='ls -l --color=auto'alias ls='ls --color=auto'alias mv='mv -i'alias rm='rm -i'alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'[root@localhost jly]# alias aming='pwd'[root@localhost jly]# aming/home/jly[root@localhost jly]# unalias aming [root@localhost jly]# amingbash: aming: 未找到命令... 通配符使用“*”来匹配0个或多个字符，用“？”匹配一个字符。1234# ls -d test*# test1.txt test2 test3 test.pl# ls -d test?# test2 test3 作业控制使用vi命令编辑test.txt:12[jly@localhost ~]$ vi test.txttesttesttest 按ESC键后使用Ctrl+z暂停任务，如下：123[jly@localhost ~]$ vi test.txt[1]+ 已停止 vim test.txt 上面提示“vi test.txt” 已经停止了，使用fg命令可以恢复它，然后又会进入刚才的vi窗口。再次使其暂停，然后输入jobs，可以看到被暂停或者在后台运行的任务：12[jly@localhost ~]$ jobs[1]+ 已停止 vim test.txt 如果想把暂停的任务放到后台重新运行，就是用bg命令(但是vi似乎不支持在后台运行)：1234[jly@localhost ~]$ bg[1]+ vim test.txt &amp;[1]+ 已停止 vim test.txt linux shell中的特殊符号 注释符号#：在#后面的内容都会被忽略。 脱义字符\\：会将后面的特殊符号（如”*”）还原为普通字符。 12[jly@localhost ~]$ ls -d test\\*ls: 无法访问test*: 没有那个文件或目录 管道符|：将前面命令的输出作为后面命令的输入。 wc命令用于统计文档的行数、字符数或词数。 符号”$”用于作变量前面的标志符。 12345[jly@localhost ~]$ ls test.txttest.txt[jly@localhost ~]$ ls !$ls test.txttest.txt 符号”~”表示用户的家目录，root用户的家目录是/root,普通用户则是/home/username 重定向符号 ‘&gt;’ 和 ‘&gt;&gt;’:分别表示取代和追加。 当我们运行一个命令报错时，报错信息会输出到当前屏幕，如果想重定向到一个文本里，则要用重定向符号“2&gt;”或者“2&gt;&gt;”,分别表示错误重定向和错误追加重定向。 正则表达式grep工具的使用命令格式：grep [-cinvABC] &#39;word&#39; filename。 -c: 表示打印符合要求的行数 -i: 表示忽略大小写 -n: 表示输出符合要求的行及行号 -v: 表示打印不符合要求的行号grep -A: 后面跟一个数字（有无空格都可以）；-A2：表示打印符合要求的行以及下面两行 -B: 后面跟一个数字；-B2：表示打印符合要求的行以及上面两行 -C: 后面跟一个数字；-C2：表示打印符合要求的行以及上下各两行 过滤(不)带有某个关键词的行并输出行号1234[jly@localhost ~]$ grep -n 'root' /etc/passwd1:root:x:0:0:root:/root:/bin/bash10:operator:x:11:0:operator:/root:/sbin/nologin43:dockerroot:x:989:984:Docker User:/var/lib/docker:/sbin/nologin 123456[jly@localhost ~]$ grep -nv 'nologin' /etc/passwd1:root:x:0:0:root:/root:/bin/bash6:sync:x:5:0:sync:/sbin:/bin/sync7:shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown8:halt:x:7:0:halt:/sbin:/sbin/halt42:jly:x:1000:1000:jly:/home/jly:/bin/bash 过滤所有包含数字的行1234[jly@localhost ~]$ grep '[0-9]' /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin 在正则表达式中，^表示行的开始，$表示行的结尾，空行则用^$表示。 [^字符],表示除[]内字符之外的字符。12345678910111213141516[jly@localhost ~]$ cat test.txt123abc456abc2323#lsadfgalllll[jly@localhost ~]$ grep '^[^a-zA-Z]' test.txt123456#lsadfg[jly@localhost ~]$ grep '[^a-zA-Z]' test.txt123456abc2323#lsadfg 指定要过滤的字符的出现次数12345678[jly@localhost ~]$ grep 'o\\&#123;2\\&#125;' /etc/passwdroot:x:0:0:root:/root:/bin/bashlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologinsetroubleshoot:x:991:988::/var/lib/setroubleshoot:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologindockerroot:x:989:984:Docker User:/var/lib/docker:/sbin/nologin egrep工具的使用筛选一个或多个前面的字符12345[jly@localhost ~]$ egrep 'o+' test.txtrot:x:0:0:/rot:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin[jly@localhost ~]$ egrep 'oo+' test.txtoperator:x:11:0:operator:/root:/sbin/nologin 筛选零个或一个前面的字符123[jly@localhost ~]$ egrep 'o?' test.txtrot:x:0:0:/rot:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin 筛选字符串1或字符串21234[jly@localhost ~]$ egrep 'aaa|111|oo' test.txtoperator:x:11:0:operator:/root:/sbin/nologin1111111111111111111111111111111111aaaaaaaaaaaaaaaaaaaaaaaaaaaa ()的应用1234[jly@localhost ~]$ egrep 'r(oo)|at(o)' test.txtoperator:x:11:0:operator:/root:/sbin/nologin[jly@localhost ~]$ egrep '(oo)+' test.txtoperator:x:11:0:operator:/root:/sbin/nologin sed工具的使用grep工具的功能还不够强大，它实现的只是查找功能，而不能把查找的内容替换。 打印某行命令格式：sed -n &#39;n&#39;p filename。1234567891011[jly@localhost ~]$ sed -n '2'p test.txtoperator:x:11:0:operator:/root:/sbin/nologin[jly@localhost ~]$ sed -n '1,$'p test.txtrot:x:0:0:/rot:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin1111111111111111111111111111111111aaaaaaaaaaaaaaaaaaaaaaaaaaaa[jly@localhost ~]$ sed -n '1,3'p test.txtrot:x:0:0:/rot:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin1111111111111111111111111111111111 第一个是打印指定的第二行，第二个是打印所有行，第三个是打印1到3行。 打印包含某个字符串的行123456[jly@localhost ~]$ sed -n '/root/'p test.txtoperator:x:11:0:operator:/root:/sbin/nologin[jly@localhost ~]$ sed -n '/^1/'p test.txt1111111111111111111111111111111111[jly@localhost ~]$ sed -n '/in$/'p test.txtoperator:x:11:0:operator:/root:/sbin/nologin sed命令加上-e选项可以实现多个行为：123[jly@localhost ~]$ sed -e '1'p -e '/111/'p -n test.txtrot:x:0:0:/rot:/bin/bash1111111111111111111111111111111111 删除某行或者多行参数“d”表示删除的动作，可以删除指定的单行以及多行，可以删除匹配某个字符的行，可以删除从某一行开始到文档最后一行的所有行。1234[jly@localhost ~]$ sed '1'd test.txtoperator:x:11:0:operator:/root:/sbin/nologin1111111111111111111111111111111111aaaaaaaaaaaaaaaaaaaaaaaaaaaa 替换字符或者字符串“s”就是替换的动作，“g”表示本行全局替换，不加g则只替换本行出现的第一个。123456[jly@localhost ~]$ sed '1,2s/ot/to/g' test.txtrto:x:0:0:/rto:/bin/bashoperator:x:11:0:operator:/roto:/sbin/nologin1111111111111111111111111111111111aaaaaaaaaaaaaaaaaaaaaaaaaaaa[jly@localhost ~]$ sed 's#ot#to#g' test.txt 上面两种格式都可以。 直接修改文件的内容123456[jly@localhost ~]$ sed -i 's/ot/to/g' test.txt[jly@localhost ~]$ cat test.txtrto:x:0:0:/rto:/bin/bashoperator:x:11:0:operator:/roto:/sbin/nologin1111111111111111111111111111111111aaaaaaaaaaaaaaaaaaaaaaaaaaaa shell脚本什么是shell？shell脚本的创建和执行编写我的第一个shell脚本（vim进入时是一般模式，按i键，进入编辑模式，按esc键退出编辑模式，然后“:wq”保存并退出vim）：12345678[root@localhost jly]# cd /usr/local/sbin/[root@localhost sbin]# vim first.sh#! /bin/bash## this is my first shell script## writen by luyaj 2017-11-18dateecho \"hello world!\" shell脚本通常是以.sh为后缀名的。本例中，脚本文件first.sh的第一行是以“#! /bin/bash”开头，表示该文件使用的是bash语法。下面执行脚本：123[root@localhost sbin]# sh first.sh2017年 11月 18日 星期六 20:31:16 CSThello world! 使用-x选项来查看脚本的执行过程：12345[root@localhost sbin]# sh -x first.sh+ date2017年 11月 18日 星期六 20:41:38 CST+ echo 'hello world!'hello world! 命令date date +%Y : 以四位数字格式打印年份 date +%y : 以两位数字格式打印年份 date +%m : 月份 date +%d : 日期 date +%H : 小时 date +%M : 分钟 date +%S : 秒 date +%w : 日期（0表示周日） 写此命令时是：2017年11月18日 20:4312345678[root@localhost sbin]# date +\"%Y-%m-%d %H:%M:%S\"2017-11-18 20:42:27[root@localhost sbin]# date -d \"-1 day\" +%d17[root@localhost sbin]# date -d \"-1 hour\" +%H19[root@localhost sbin]# date -d \"-1 min\" +%M42 shell脚本中的变量数学运算1234567a=1b=2sum=$[$a+$b]echo \"$a+$b=$sum\"[root@localhost sbin]# sh first.sh1+2=3 和用户交互(read)123456789read -p \"please input a number:\" xread -p \"please input another number:\" ysum=$[$x+$y]echo \"the sum of the two num is: $sum\"[root@localhost sbin]# sh first.shplease input a number:2please input another number:4the sum of the two num is: 6 shell脚本预设变量1234567[root@localhost sbin]# vim first.shsum=$[$1+$2]echo \"$sum\"[root@localhost sbin]# sh -x first.sh 1 2+ sum=3+ echo 33 脚本中的$1和$2就是shell脚本的预设变量。另外还有$0,表示脚本本身的名字：123echo \"$1 $2 $0\"[root@localhost sbin]# sh first.sh 1 21 2 first.sh shell脚本中的逻辑判断不带else12345678910[root@localhost sbin]# cat first.sh#! /bin/bashreadread -p \"please input you score:\" aif((a&lt;60)); then echo \"you fail\"fi[root@localhost sbin]# sh first.shplease input you score:34you fail “((a&lt;60))”是shell脚本中特有的格式，只用一个小括号或者不用都会报错。 带有else123456789101112131415[root@localhost sbin]# cat first.sh#! /bin/bashread -p \"please input you score:\" aif((a&lt;60)); then echo \"you fail.\"else echo \"good!pass it.\"fi[root@localhost sbin]# sh first.shplease input you score:45you fail.[root@localhost sbin]# sh first.shplease input you score:90good!pass it. 带有elif1234567891011[root@localhost sbin]# cat first.sh#! /bin/bashread -p \"please input you score:\" aif((a&lt;60)); then echo \"you fail.\"elif ((a&gt;=60)) &amp;&amp; ((a&lt;85)); then echo \"good!pass it.\"else echo \"very good!is so high.\"fi 判断数值大小除了可以用(())的形式外，还可以使用[]，但是不能使用&gt;、&lt;、=这样的符号了，要使用-lt(小于)、-gt(大于)、-le(小于或等于)、-ge(大于或等于)，-eq(等于)，-ne(不等于)。 case逻辑判断12345678910111213141516read -p \"input a number:\" na=$[$n%2]case $a in1) echo \"the num is odd\" ;;0) echo \"the num is even\" ;;*) echo \"it's not a num\" ;;esac[root@localhost sbin]# sh first.shinput a number:20the num is even shell脚本的循环for循环“seq 1 5”表示从1到5的一个序列：123456789for i in `seq 1 5`; do echo $idone[root@localhost sbin]# sh first.sh12345 循环条件也可以是一组字符串或者数字：1234[root@localhost sbin]# for i in 1 a b;do echo $i;done1ab shell脚本中的函数1234567function sum()&#123; sum=$[$1+$2] echo $sum&#125;sum $1 $2[root@localhost sbin]# sh first.sh 1 23 注意，在shell脚本中，函数一定要写在最前面，因为函数是要被调用的，如果还没有出现就被调用，肯定会出错的。 linux系统日常管理监控系统的状态w查看当前系统的负载主要关注load average后的三个值，表示单位时间段内CPU的活动进程数，这个值越大就说明服务器压力越大，一般情况下，这个值只要不超过服务器的CPU数量就没有关系。12345[jly@localhost ~]$ w 21:40:29 up 2 min, 2 users, load average: 1.68, 0.99, 0.39USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATjly :0 :0 21:39 ?xdm? 24.29s 0.42s gdm-session-worker [pajly pts/0 :0 21:39 5.00s 0.11s 0.04s w 查看服务器有几个CPU的方法：1234567891011121314151617181920212223242526[jly@localhost ~]$ cat /proc/cpuinfoprocessor : 0vendor_id : GenuineIntelcpu family : 6model : 61model name : Intel(R) Core(TM) i5-5200U CPU @ 2.20GHzstepping : 4microcode : 0x1fcpu MHz : 2200.448cache size : 3072 KBphysical id : 0siblings : 1core id : 0cpu cores : 1apicid : 0initial apicid : 0fpu : yesfpu_exception : yescpuid level : 20wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc aperfmperf eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch ida arat epb pln pts dtherm fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid rdseed adx smap xsaveoptbogomips : 4402.00clflush size : 64cache_alignment : 64address sizes : 42 bits physical, 48 bits virtualpower management: vmstat监控系统的状态命令w查看系统整体上的负载，可以查看系统有没有压力，但无法判断具体是哪里（CPU、内存、磁盘等）有压力，所以就用vmstat。vmstat命令打印有以下6部分(列举常用的)： procs显示进程的相关信息 r：表示运行和等待CPU时间片的进程数，该数值如果长期大于服务器CPU的个数，则说明CPU不够用了。 b：表示等待资源的进程数，比如等待I/O、内存等。 memory显示内存的相关信息 swap显示内存的交换情况 si：表示由交换区写入到内存的数据量 so：表示由内存写入到交换区的数据量 io显示磁盘的使用情况 bi：表示从块设备读取数据的量（读磁盘） bo：表示从块设备写入数据的量（写磁盘） system显示采集间隔内发生的中段次数 cpu显示CPU的使用状态 wa：表示I/O等待所占用CPU的时间百分比 1234[jly@localhost ~]$ vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 3 0 3156 66000 36 436188 0 2 894 78 125 213 3 2 92 3 0 也可以使用命令vmstat 1 5或者vmstat 1，前一条命令表示每隔1秒输出一次状态，共输出5次；后一条命令表示每隔1秒输出一次状态且一直输出。 top显示进程占有的系统资源free查看内存使用的状态1234[jly@localhost ~]$ free total used free shared buff/cache availableMem: 999936 574212 90404 4844 335320 224880Swap: 2097148 7244 2089904 ps查看系统进程网络相关 ifconfig：查看网卡IP service network restart：重启网卡 hostname：查看（修改）主机名12345[jly@localhost ~]$ hostnamelocalhost.localdomain[root@localhost jly]# hostname jiangluya //修改主机名[root@localhost jly]# hostnamejiangluya 下次登录时，命令提示符[root@localhost ~]中的localhost就会改为jiangluya。但是这样的修改只是保存在内存在，如果重启，主机名还会变成未改之前的名称。所以更改主机名的同时还需要更改相关配置文件/etc/sysconfig/network。123vim /etc/sysconfig/networkNETWORKING=yesHOSTNAME=jiangluya.localdomain #","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"一些工具使用","date":"2017-10-27T14:32:16.000Z","path":"2017/10/27/一些工具使用/","text":"兴致来了，记录下自己喜欢的小工具，不定期更新。 第一个工具 —— 使用Emoji嗯，Emoji，在github里使用的emoji，好可爱的~ 看到这个好东西是来自前端早读课的第1083期文章，附上文章地址【第1083期】git commit时使用 Emoji。 使用起来很简单,直接在在emoji名字的前后各加上一个冒号：1$ git commit -m \":sparkles:腾讯课堂NEXT学位\" 效果展示： github上的源码–gitmoji An emoji guide for your commit messages在这里看图标的名称。 webstorm本人常用快捷键记录: Alt: 选择多处 Ctrl+d: 复制并粘贴一行","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"归并排序实现的三种方式","date":"2017-10-23T08:31:18.000Z","path":"2017/10/23/归并排序实现的三种方式/","text":"算法课上老师布置的第一次上机实验。归并排序，一个分治的策略，先进行划分，再进行合并。空间复杂度：nlogn 递归实现的归并排序基本思想：将待排的元素分成大小大致相同的2个子集，分别对这两个子集进行排序，最终将排好序的子集合并，就会得到一个排好序的集合。 设当前归并排序的区间是[left..right],分治法的三个步骤是： 1.分解：将当前区间一分为二，即求分裂点 2.求解：递归的对两个子区间[left..mid]和[mid+1..right]进行归并排序 3.组合：将已排序的两个子区间[left..mid]和[mid+1..right]归并为一个有序的区间[left..right]。 实现过程如图： 代码实现：","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"学习linux","date":"2017-10-15T12:02:49.000Z","path":"2017/10/15/学习linux/","text":"简介：使用虚拟机安装linux以及linux学习。 VMware Workstation Pro：下载地址 CentOS：下载地址 书籍推荐：《跟阿铭学Linux》2014年10月第1版 实验楼：学习地址 虚拟机安装Linux《跟阿铭学Linux》这里面也有详细的安装过程，这里我就记录两点： 习惯于用图形界面的同学一定要记得选择这项，不然之后安装有点麻烦。 刚点击install CentOS 7 ，就发现界面黑屏，怎么弄都没有反应，这个时候就要注意，是不是电脑禁止了虚拟机功能。解决办法：重启电脑进入BIOS，找到virtualization的一项,我的BIOS中在Advanced-cpu setup-virtualization，现为Disabled状态，改为Enable，再开机安装这个问题应该解决了！ 其他的可以参考这篇文章，讲的很详细。（CentOs安装教程等） 基础小笔记 切换用户：su 用户名 (su root) 新建目录：mkdir 目录名 新建文件：touch 文件名 切换路径：cd 路径地址 关机命令：init 0 重要快捷键 tab键:写命令时，命令不记得，那就用Tab补全 Ctrl+c:强行终止当前程序 按键 作用 Ctrl+d 键盘输入结束或退出终端 Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行 Ctrl+z 将当前程序放到后台运行，恢复到前台为命令fg Ctrl+a 将光标移至输入行头，相当于Home键 Ctrl+e 将光标移至输入行末，相当于End键 Ctrl+k 删除从光标所在位置到行末 Alt+Backspace 向前删除一个单词 Shift+PgUp 将终端显示向上滚动 Shift+PgDn 将终端显示向下滚动 方向键↑:恢复之前输入过的命令 Shell常用通配符 字符 含义 * 匹配0或多个字符 ? 匹配任意一个字符 [list] 匹配list中的任意单一字符 [!list] 匹配除list中的任意单一字符以外的字符 [c1-c2] 匹配c1-c2中的任意单一字符,如：[0-9] [a-z] {string1,string2,…} 匹配string1或string2(或更多)其一字符串 {c1…c2} 匹配c1-c2中全部字符，如{1..10} 一次性创建多个文件：123[luyaj@localhost test]$ touch hello&#123;1..3&#125;.html[luyaj@localhost test]$ ls *.htmlhello1.html hello2.html hello3.html 在命令行中获取帮助你可以使用如下方式来获得某个命令的说明和使用方式的详细介绍:1$ man &lt;command_name&gt; 由于man的命令很多，所以手册进行了分区段处理，通常被分为以下8个区段： 区段 说明 1 一般命令 2 系统调用 3 库函数，涵盖了C标准函数库 4 特殊文件（通常是/dev中的设备）和驱动程序 5 文件格式和约定 6 游戏和屏保 7 杂项 8 系统管理命令和守护进程 例如：1$ man 1 ls 如果你知道某个命令的作用，只是想快速查看一些它的某个具体参数的作用，那么你可以使用–help参数，大部分命令都会带有这个参数，如：1$ ls --help Linux文件和目录管理跟文件和目录有关的命令命令cd命令cd是用来变更用户所在目录的，后面只能跟目录名，跟了文件名会报错；命令pwd是用来打印当前所在目录：12345[luyaj@localhost ~]$ cd homebash: cd: home: 没有那个文件或目录[luyaj@localhost ~]$ cd /home[luyaj@localhost home]$ pwd/home 在linux文件系统中，有两个特殊的符号也可以表示目录。”.”表示当前目录，”..”表示当前目录的上一级目录：123456[luyaj@localhost test]$ cd .[luyaj@localhost test]$ pwd/home/luyaj/test[luyaj@localhost test]$ cd ..[luyaj@localhost ~]$ pwd/home/luyaj 命令mkdirmkdir是make directory的缩写。命令格式是：mkdir [-mp][目录名称]。-m选项用于指定要创建目录的权限（不常用）；-p选项很有用处，我们先来看看： 12345[luyaj@localhost ~]$ mkdir luya/test/123mkdir: 无法创建目录\"luya/test/123\": 没有那个文件或目录[luyaj@localhost ~]$ mkdir -p luya/test/123[luyaj@localhost ~]$ ls luya/test123 我们发现当我们想创建目录luya/test/123时，提示无法创建、/luya/test文件不存在。这是因为在linux中，如果发现要创建的目录的上一级目录不存在就会报错。所以-p这个选项就是帮我们创建一大串级联目录，并且当创建一个已经存在的目录时不会报错。 相应的，rmdir用于删除空目录。 命令rmrm命令既可以删除目录，也可以删除文件。一般使用命令rm -rf 目录名来删除。 命令cpcp是copy的简写，命令格式：cp [选项][来源文件][目的文件]。 -r :如果要复制一个目录，必须加这个选项，否则不能复制目录，类似于rm命令。 12345678[luyaj@localhost ~]$ mkdir 123[luyaj@localhost ~]$ cp 123 456cp: 略过目录\"123\"[luyaj@localhost ~]$ cp -r 123 456[luyaj@localhost ~]$ ls -l总用量 0drwxrwxr-x. 2 luyaj luyaj 6 10月 16 19:42 123drwxrwxr-x. 2 luyaj luyaj 6 10月 16 19:42 456 -i :如果遇到一个已经存在的文件，会询问是否覆盖。 1234567891011121314[luyaj@localhost ~]$ cd 123[luyaj@localhost 123]$ ls[luyaj@localhost 123]$ touch 111[luyaj@localhost 123]$ touch 222[luyaj@localhost 123]$ cp -i 111 222cp：是否覆盖\"222\"？ n[luyaj@localhost 123]$ echo 'acb' &gt; 111[luyaj@localhost 123]$ echo 'def' &gt; 222[luyaj@localhost 123]$ cat 111 222acbdef[luyaj@localhost 123]$ /bin/cp 111 222[luyaj@localhost 123]$ cat 111acb 上例中，echo用于打印，将’abc’和’def’分别写入文件”111”和”222”中，起写入符号的就是符号”&gt;”(在linux中叫做重定向)。cat命令用于读一个文件，并把读出的文件打印在当前屏幕上。 命令mvmv是move的简写，命令格式为：mv [选项][源文件或目录][目标文件或目录]。 有几种情况，先看示例： 12345678[luyaj@localhost ~]$ mkdir dira dirb[luyaj@localhost ~]$ lsdira 公共 视频 文档 音乐dirb 模板 图片 下载 桌面[luyaj@localhost ~]$ mv dira dirc[luyaj@localhost ~]$ lsdirb 公共 视频 文档 音乐dirc 模板 图片 下载 桌面 这里，目标文件是目录dirc，并且dirc不存在，所以相当于把目录dira重命名为dirc。 12345[luyaj@localhost ~]$ mv dirc dirb[luyaj@localhost ~]$ lsdirb 公共 模板 视频 图片 文档 下载 音乐 桌面[luyaj@localhost ~]$ ls dirbdirc 这里，目标文件是目录dirb，并且dirb存在，所以会把目录dirc移动到目录dirb里。 同理，文件的移动也是和上面目录的移动是一样的。 几个与文档相关的命令命令cat/taccat命令用来查看一个文件的内容并显示在屏幕上；而tac命令是反序输出。 -n ：查看文件时，把行号也显示在屏幕上 -A ：显示所有内容，包括特殊字符 123456789101112131415[luyaj@localhost ~]$ mkdir dirb[luyaj@localhost ~]$ cd dirb[luyaj@localhost dirb]$ touch filee[luyaj@localhost dirb]$ echo '111111' &gt; filee[luyaj@localhost dirb]$ echo '222222' &gt;&gt;filee[luyaj@localhost dirb]$ cd[luyaj@localhost ~]$ cat dirb/filee111111222222[luyaj@localhost ~]$ cat -n dirb/filee 1 111111 2 222222[luyaj@localhost ~]$ cat -A dirb/filee111111$222222$ 这里’&gt;&gt;’也是重定向，是追加的意思。只是使用’&gt;’符号时，如果文件中有内容会删除文件中原来的内容，而使用’&gt;&gt;’符号不会删除原有内容。 命令more/less/head/tail 当文件内容太多时，一屏不能全部显示时，用cat肯定是看不了前面的内容，而使用more可以解决这个问题。当看完一屏后，按空格键可以继续看下一屏。如果想提前退出，按”q”键即可。 less和more命令一样，但是命令less可以实现上翻和下翻。 命令head用于显示文件的前10行，如果加-n选项则显示文件的前几行。 命令tail用于显示文件的最后10行，如果加-n选项则显示文件的后几行。 linux文件属性1234[luyaj@localhost ~]$ ls -l总用量 0drwxrwxr-x. 2 luyaj luyaj 19 10月 16 22:16 dirbdrwxr-xr-x. 2 luyaj luyaj 6 10月 16 01:43 公共 使用命令ls -l共显示了9列内容，那么他们都代表什么含义呢？ 第1列：包含该文件的类型、所属主、所属组以及其他用户对该文件的权限。第1位用来描述该文件的类型。 d表示该文件为目录 -表示该文件为普通文件 l表示该文件为链接文件 b表示该文件为块设备，比如/dev/sda就是这样的文件 c表示该文件为串行端口设备文件（又称字符设备文件），比如键盘、鼠标、打印机、tty终端等 s表示该文件为套接字文件，用于进程之间的通信 文件类型后面9位，每3个一组，前3位为所属主（user）的权限，中间3位为所属组（group）的权限，最后3位为其他非本群组用户（others）的权限。”r”表示可读，”w”表示可写，”x”表示可执行。 第2列：表示链接占用的节点（inode），如果是目录，那么与该目录下是子目录数量有关 第3列：表示文件的所属主 第4列：表示文件的所属组 第5列：表示该文件的大小 第6列、第7列和第8列：表示文件最后一次被修改的时间，依次为月份、日期、时间 第9列：表示文件名 更改文件的权限命令chgrp更改文件和目录的所属组，命令格式：chgrp [组名] [文件名] 1234567[root@localhost ~]# groupadd testgroup[root@localhost ~]# touch test1[root@localhost ~]# ls -l test1-rw-r--r--. 1 root root 0 10月 16 23:17 test1[root@localhost ~]# chgrp testgroup test1[root@localhost ~]# ls -l test1-rw-r--r--. 1 root testgroup 0 10月 16 23:17 test1 groupadd命令的含义为增加一个用户组。 命令chown更改文件和目录的所属主，命令格式：chown [-R] 账户名 文件名 或者 chown [-R] 账户名：组名 文件名。这里的-R选项只适用于目录，作用是级联更改，即不仅更改当前目录，连目录里的目录或者文件也全部更改。 命令chmodchmod命令用于改变用户对文件的读写执行权限，其格式为：“chmod [-R] xyz 文件名”。其中-R表示级联更改；xyz表示数字，即在linux中为了方便更改文件的权限，使用数字代替“rwx”，规则为：r等于4，w等于2，x等于1，-等于0。例如，“-rwxrwx—”用数字表示就是770。 12345[luyaj@localhost ~]$ ls -ld testdrwxrwxr-x. 2 luyaj luyaj 19 10月 17 03:25 test[luyaj@localhost ~]$ chmod 750 test[luyaj@localhost ~]$ ls -ld testdrwxr-x---. 2 luyaj luyaj 19 10月 17 03:25 test 在linux系统中，一个目录的默认权限为755，而一个文件的默认权限为644。 在linux下搜索文件命令which用which命令查找PATH环境变量中的可执行文件的绝对路径。 123[luyaj@localhost ~]$ which vialias vi='vim' /usr/bin/vim 命令whereiswhich命令是通过预先生成的一个文件列表库去查找与给出的文件名相关的文件，格式：whereis [-bmsu] [文件名称]。 12[luyaj@localhost ~]$ whereis lsls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz 这里，我们有3个文件被找到了，类似于模糊查询。 命令find使用find命令搜索文件，命令格式：find [路径] [参数]。 -atime +n/-n:表示访问或执行时间大于或小于n天的文件。 ctime +n/-n:表示写入、更改inode属性（如更改所有者、权限或者链接）时间大于或小于n天的文件。 -mtime +n/-n:表示写入时间大于或小于n天的文件。 -name filename:表示直接查找该文件名的文件。123456[root@localhost luyaj]# mkdir test[root@localhost luyaj]# mkdir test/test2[root@localhost luyaj]# find . -name test2./test/test2[root@localhost luyaj]# find -name test2./test/test2 linux系统用户与用户组管理用户和用户组管理新增组的命令groupadd命令格式：groupadd [-g GID] groupname。 123[root@localhost luyaj]# groupadd grptest1[root@localhost luyaj]# tail -n1 /etc/groupgrptest1:x:1003: 如果不加“-g”选项则按照系统默认的gid创建组。跟uid一样，gid也是从500开始，我们也可以自定义gid： 1234[root@localhost luyaj]# groupadd -g 511 grptest2[root@localhost luyaj]# tail -n2 /etc/groupgrptest1:x:1003:grptest2:x:511: 删除组的命令groupdel12345[root@localhost luyaj]# groupdel grptest2[root@localhost luyaj]# tail -n3 /etc/groupluyaj:x:1000:user1:x:1002:grptest1:x:1003: groupdel命令无特殊选项，但有一种情况不能删除组： 12[root@localhost luyaj]# groupdel user1groupdel：不能移除用户“user1”的主组 这个例子中，user1组中包含user1账户，只有先删除账户才可以删除该组。 增加用户的命令useradd命令格式：useradd [-u UID][-g GID][-d HOME][-M][-s]，各个选项的含义如下： -u：表示自定义UID。 -g：表示使新增用户属于已经存在的某个组，后面可以跟组id，也可以跟组名。 -d：表示自定义用户的家目录。 -M：表示不建立家目录。 -s：表示自定义shell。 下面我们新建一个用户test10，示例如下：12345[root@localhost luyaj]# useradd test10[root@localhost luyaj]# tail -n1 /etc/passwdtest10:x:1002:1004::/home/test10:/bin/bash[root@localhost luyaj]# tail -n1 /etc/grouptest10:x:1004: 如果useradd不加任何选项，直接跟用户名，那么会创建一个跟用户名同名的组。有的时候需要我们自己去定义： 12[root@localhost luyaj]# useradd -u510 -g 513 -M -s /sbin/nologin user11useradd：“513”组不存在 删除账户的命令userdel命令格式：userdel [-r] username，其中-r选项的作用是，当删除用户时一并删除该用户的家目录。 1234567[root@localhost luyaj]# userdel user1[root@localhost luyaj]# tail -n3 /etc/passwdtcpdump:x:72:72::/:/sbin/nologinluyaj:x:1000:1000:luyaJ:/home/luyaj:/bin/bashtest10:x:1002:1004::/home/test10:/bin/bash[root@localhost luyaj]# ls -ld /home/user1drwx------. 3 1001 1002 78 10月 16 23:35 /home/user1 这里可以看出，未加选项时，只删除了用户，没有家目录还在。 用户密码管理命令passwd为用户设置密码可以使用命令passwd，命令格式：passwd [username]。 12345[root@localhost luyaj]# passwd更改用户 root 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。 如果你登陆的是root账号，后面可以跟普通用户的名字，意思是修改指定账户的密码：123456[root@localhost luyaj]# passwd test10更改用户 test10 的密码 。新的 密码：无效的密码： 密码未通过字典检查 - 它基于字典单词重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。 需要注意的是，只有root才能修改其他账户的密码，普通账户只能修改自己的密码。 命令mkpasswd用于生成密码。 linux磁盘管理查看磁盘或者目录的容量命令df命令df用来查看已挂载磁盘的总容量、使用容量、剩余容量，可以不加任何参数，默认以KB为单位显示： 12345678910[luyaj@localhost ~]$ df文件系统 1K-块 已用 可用 已用% 挂载点/dev/mapper/cl-root 17811456 3454476 14356980 20% /devtmpfs 484108 0 484108 0% /devtmpfs 499968 156 499812 1% /dev/shmtmpfs 499968 7188 492780 2% /runtmpfs 499968 0 499968 0% /sys/fs/cgroup/dev/sda1 1038336 176564 861772 18% /boottmpfs 99996 24 99972 1% /run/user/1000/dev/sr0 4276440 4276440 0 100% /run/media/luyaj/CentOS 7 x86_64 df命令的常用选项有-i、-h、-k和-m： -i：表示查看inodes的使用状况： 12345678910[luyaj@localhost ~]$ df -i文件系统 Inode 已用(I) 可用(I) 已用(I)% 挂载点/dev/mapper/cl-root 8910848 119944 8790904 2% /devtmpfs 121027 391 120636 1% /devtmpfs 124992 10 124982 1% /dev/shmtmpfs 124992 546 124446 1% /runtmpfs 124992 16 124976 1% /sys/fs/cgroup/dev/sda1 524288 330 523958 1% /boottmpfs 124992 30 124962 1% /run/user/1000/dev/sr0 0 0 0 - /run/media/luyaj/CentOS 7 x86_64 -h：表示使用合适的单位显示，例如G： 12345678910[luyaj@localhost ~]$ df -h文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/cl-root 17G 3.3G 14G 20% /devtmpfs 473M 0 473M 0% /devtmpfs 489M 156K 489M 1% /dev/shmtmpfs 489M 7.1M 482M 2% /runtmpfs 489M 0 489M 0% /sys/fs/cgroup/dev/sda1 1014M 173M 842M 18% /boottmpfs 98M 24K 98M 1% /run/user/1000/dev/sr0 4.1G 4.1G 0 100% /run/media/luyaj/CentOS 7 x86_64 -k、-m：分别以”K”和”M”为单位显示： 1234567891011121314151617181920[luyaj@localhost ~]$ df -k文件系统 1K-块 已用 可用 已用% 挂载点/dev/mapper/cl-root 17811456 3454460 14356996 20% /devtmpfs 484108 0 484108 0% /devtmpfs 499968 156 499812 1% /dev/shmtmpfs 499968 7188 492780 2% /runtmpfs 499968 0 499968 0% /sys/fs/cgroup/dev/sda1 1038336 176564 861772 18% /boottmpfs 99996 24 99972 1% /run/user/1000/dev/sr0 4276440 4276440 0 100% /run/media/luyaj/CentOS 7 x86_64[luyaj@localhost ~]$ df -m文件系统 1M-块 已用 可用 已用% 挂载点/dev/mapper/cl-root 17394 3374 14021 20% /devtmpfs 473 0 473 0% /devtmpfs 489 1 489 1% /dev/shmtmpfs 489 8 482 2% /runtmpfs 489 0 489 0% /sys/fs/cgroup/dev/sda1 1014 173 842 18% /boottmpfs 98 1 98 1% /run/user/1000/dev/sr0 4177 4177 0 100% /run/media/luyaj/CentOS 7 x86_64 /dev/shm为内存挂载点，如果你想把文件放到内存里，就可以放到这个目录下。 命令du用来查看某个目录或文件所占空间的大小，命令格式：du [-abckmsh][文件或者目录名]。 -a：表示全部文件和目录的大小都列出来。如果不指定单位，默认显示单位为”KB”。 -b：表示列出的值以”bytes”为单位输出。 -k：表示以”KB”为单位输出，这和不加选项是一样的。 -m：表示以”MB”为单位输出。 -h：表示系统自动调节单位。 -c：表示最后加总。 -s：表示只列出总和。123456789101112131415161718192021222324[luyaj@localhost ~]$ du test0 test/test20 test/test30 test[luyaj@localhost ~]$ du -a test0 test/test20 test/test3/1.txt0 test/test30 test[luyaj@localhost ~]$ du -b /etc/passwd2233 /etc/passwd[luyaj@localhost ~]$ du -k /etc/passwd4 /etc/passwd[luyaj@localhost ~]$ du -m /etc/passwd1 /etc/passwd[luyaj@localhost ~]$ du -h /etc/passwd4.0K /etc/passwd[luyaj@localhost ~]$ du -c test0 test/test20 test/test30 test0 总用量[luyaj@localhost ~]$ du -s test0 test 磁盘的分区和格式化用文件来表示硬件分区——/dev/sda5解释一下： dev是存放所有硬件设备文件的目录 sd是硬件设备的代号，hd代表IDE设备，sd代表SCSI和sata设备 a是同类型设备的编号，a代表第一个硬盘，b代表第二个硬盘，以此类推 5是分区号：1~4表示主分区或拓展分区，5表示逻辑分区举几个例子： /dev/sdb3：计算机中第二块SATA硬盘的第三个主分区。 /dev/sda8：计算机中第一块SATA硬盘的第四个逻辑分区。 /dev/hda1：计算机中第四块IDE硬盘的第一个主分区 增加虚拟磁盘在系统关机的状态下，选择你的虚拟机，右键设置，然后添加硬盘，创建新虚拟磁盘，将虚拟磁盘拆分成多个文件，完成。 命令fdisk这里我已经创建好了新的磁盘，所以执行命令fdisk -l会发现新增了一个磁盘”/dev/sdb”。 如果只执行命令fdisk /dev/sda就会进入另一种模式，在这个模式下，可以对磁盘进行分区操作。 1234567891011121314151617181920212223242526272829[root@localhost luyaj]# fdisk /dev/sdb欢迎使用 fdisk (util-linux 2.23.2)。更改将停留在内存中，直到您决定将更改写入磁盘。使用写入命令前请三思。Device does not contain a recognized partition table使用磁盘标识符 0xad054854 创建新的 DOS 磁盘标签。命令(输入 m 获取帮助)：m命令操作 a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition g create a new empty GPT partition table G create an IRIX (SGI) partition table l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition’s system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only) 输入p命令，我们可以看到当前无分区：12345678910命令(输入 m 获取帮助)：p磁盘 /dev/sdb：8589 MB, 8589934592 字节，16777216 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0xad054854 设备 Boot Start End Blocks Id System 那么我们开始创建分区：123456789命令(输入 m 获取帮助)：nPartition type: p primary (0 primary, 0 extended, 4 free) e extendedSelect (default p): p分区号 (1-4，默认 1)：1起始 扇区 (2048-16777215，默认为 2048)：2048Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-16777215，默认为 16777215)：+1000M分区 1 已设置为 Linux 类型，大小设为 1000 MiB 使用n命令新建分区，选择p（主分区），分区号，起始扇区都可以默认不填（或者你也可以填），Last扇区填“+1000M”，这样方便又不容易出错。一直创建主分区到4，我们可以看到： 1234567891011命令(输入 m 获取帮助)：nPartition type: p primary (3 primary, 0 extended, 1 free) e extendedSelect (default e): Using default response e已选择分区 4起始 扇区 (6146048-16777215，默认为 6146048)：将使用默认值 6146048Last 扇区, +扇区 or +size&#123;K,M,G&#125; (6146048-16777215，默认为 16777215)：+1000M分区 4 已设置为 Extended 类型，大小设为 1000 MiB 上面就是，创建完第3个分区之后，创建第4个分区时选择拓展分区，输入命令p查看：1234567891011121314命令(输入 m 获取帮助)：p磁盘 /dev/sdb：8589 MB, 8589934592 字节，16777216 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0xbfa73b9f 设备 Boot Start End Blocks Id System/dev/sdb1 2048 2050047 1024000 83 Linux/dev/sdb2 2050048 4098047 1024000 83 Linux/dev/sdb3 4098048 6146047 1024000 83 Linux/dev/sdb4 6146048 8194047 1024000 5 Extended 接下来我们继续创建分区：123456789101112131415161718192021222324命令(输入 m 获取帮助)：nAll primary partitions are in use添加逻辑分区 5起始 扇区 (6148096-8194047，默认为 6148096)：将使用默认值 6148096Last 扇区, +扇区 or +size&#123;K,M,G&#125; (6148096-8194047，默认为 8194047)：将使用默认值 8194047分区 5 已设置为 Linux 类型，大小设为 999 MiB命令(输入 m 获取帮助)：p磁盘 /dev/sdb：8589 MB, 8589934592 字节，16777216 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0xbfa73b9f 设备 Boot Start End Blocks Id System/dev/sdb1 2048 2050047 1024000 83 Linux/dev/sdb2 2050048 4098047 1024000 83 Linux/dev/sdb3 4098048 6146047 1024000 83 Linux/dev/sdb4 6146048 8194047 1024000 5 Extended/dev/sdb5 6148096 8194047 1022976 83 Linux 此时再分区就跟之前的不一样了，只需要直接定义分区大小就可以了。需要注意的是，当创建完前3个主分区后，要把剩余的磁盘空间全部划分给第4个拓展分区，不然剩下的空间就浪费了。因为创建完拓展分区后，再划分新的分区时是在已经划分的拓展分区里来分的。 注意：“/dev/sdb4”为拓展分区，这个分区是不可以格式化的。“/dev/sdb5”是“/dev/sdb4”的子分区，称为逻辑分区。删除分区使用命令d，在弄好的分区界面直接按“Ctrl+c”键可以直接退出，这样刚做的分区便全部取消。 格式化磁盘分区磁盘分区好了，需要对每个分区进行格式化才能使用。所谓格式化，就是安装文件系统，Windows下的文件系统有Fat32和NTFS，CentOS使用的文件系统是ext。 使用man命令可以看出mke2fs,mkfs.ext2,mkfs.ext3,mkfs.etx4这4个命令是一样的。 把新建的分区格式化为ext4文件系统：123456789101112131415161718192021[root@localhost jly]# mkfs.ext4 /dev/sdb1mke2fs 1.42.9 (28-Dec-2013)文件系统标签=OS type: Linux块大小=4096 (log=2)分块大小=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks64000 inodes, 256000 blocks12800 blocks (5.00%) reserved for the super user第一个数据块=0Maximum filesystem blocks=2621440008 block groups32768 blocks per group, 32768 fragments per group8000 inodes per groupSuperblock backups stored on blocks: 32768, 98304, 163840, 229376Allocating group tables: 完成 正在写入inode表: 完成 Creating journal (4096 blocks): 完成Writing superblocks and filesystem accounting information: 完成 挂载/卸载磁盘挂载到’/mnt’空目录上，此后操作’/mnt’目录就是操作’/dev/sda3’分区，例如在里面创建目录，拷贝文件等。1[root@localhost jly]# mount /dev/sdb1 /mnt 查看已挂载分区的使用情况：1234567891011[root@localhost jly]# df -T文件系统 类型 1K-块 已用 可用 已用% 挂载点/dev/mapper/cl-root xfs 17811456 3454780 14356676 20% /devtmpfs devtmpfs 484108 0 484108 0% /devtmpfs tmpfs 499968 156 499812 1% /dev/shmtmpfs tmpfs 499968 7192 492776 2% /runtmpfs tmpfs 499968 0 499968 0% /sys/fs/cgroup/dev/sda1 xfs 1038336 176564 861772 18% /boottmpfs tmpfs 99996 8 99988 1% /run/user/1000/dev/sr0 iso9660 4276440 4276440 0 100% /run/media/jly/CentOS 7 x86_64/dev/sdb1 ext4 991512 2504 921424 1% /mnt 卸载分区：1[root@localhost jly]# umount /mnt 文档的压缩与打包 .gz:表示由gzip压缩工具压缩的文件 .bz2:表示由bzip2压缩工具压缩的文件 .tar:表示由tar打包程序打包的文件（tar并没有压缩功能，只是把一个目录合并成一个文件） .tar.gz:可以理解为先由tar打包，再由gzip压缩 .tar.bz2:可以理解为先由tar打包，再由bzip2压缩 gzip压缩gzip命令格式：gzip [-d#] filename。-d:在解压缩时使用；-#表示压缩等级，1为最差，9为最好，默认为6。 123456789mkdir test[jly@localhost ~]$ touch test.txt[jly@localhost ~]$ mv test.txt test[jly@localhost ~]$ cd test[jly@localhost test]$ lstest.txt[jly@localhost test]$ gzip test.txt[jly@localhost test]$ lstest.txt.gz 由上面可以看出，gzip后面直接跟文件名，表示在该目录下压缩该文件，而原文件也会消失。 123[jly@localhost test]$ gzip -d test.txt.gz[jly@localhost test]$ lstest.txt 使用gzip -d命令表示解压压缩文件。gzip不支持压缩目录。 bzip2压缩工具bzip2命令格式：bzip2 [-dz] filename。-z压缩（加不加都可以压缩），-d解压缩。 123456[jly@localhost test]$ bzip2 test.txt[jly@localhost test]$ lstest.txt.bz2[jly@localhost test]$ bzip2 -d test.txt.bz2[jly@localhost test]$ lstest.txt tar压缩工具tar本身就是一个大包工具，可以把目录打包成一个文件，它把所有的文件整合成一个大文件整体，方便复制或移动。命令格式：tar [-zjxcvfpP] filename tar。下面介绍下常用的参数： -z:表示同时用gzip压缩 -j:表示同时用bzip2压缩 -x:表示解包或解压缩 -t:表示查看tar包里的文件 -c:表示建立一个tar包或者压缩文件包 -v:表示可视化 -f:后面跟文件名（即“-f filename”），表示压缩后的文件名为filename，或者解压文件filename。注意，在有多个参数的情况下，将-f参数写在最后面。 123456789101112[jly@localhost test]$ bzip2 test.txt[jly@localhost test]$ mkdir test111[jly@localhost test]$ touch test111/test2.txt[jly@localhost test]$ echo \"nihao\" &gt; !$echo \"nihao\" &gt; test111/test2.txt[jly@localhost test]$ lstest111 test.txt.bz2[jly@localhost test]$ tar -cvf test111.tar test111test111/test111/test2.txt[jly@localhost test]$ lstest111 test111.tar test.txt.bz2 上例中，使用tar命令把test111打包成test111.tar（记住-f参数后紧跟打包后的文件名，然后再跟需要打包的目录或文件）。且使用tar命令打包，原文件也不会消失。 不加-v，表示不可视化。第2行的意思是–将test111和test.txt.bz2一起打包在test.tar中。1234[jly@localhost test]$ rm -f test111.tar[jly@localhost test]$ tar -cf test.tar test111 test.txt.bz2[jly@localhost test]$ lstest111 test.tar test.txt.bz2 注意：不管是打包还是解包，原来的文件都不会删除的，而且会覆盖当前已经存在的文件或者是目录。 打包的同时使用gzip压缩tar命令非常好用的功能就是可以在打包时直接压缩，支持gzip压缩和bzip2压缩。 gzip压缩方法：12345[jly@localhost test]$ tar -czvf test111.tar.gz test111test111/test111/test2.txt[jly@localhost test]$ lstest111 test111.tar.gz test.tar test.txt.bz2 使用-zxvf选项解压.tar.gz格式的压缩包：12345678[jly@localhost test]$ rm -rf test111[jly@localhost test]$ lstest111.tar.gz test.tar test.txt.bz2[jly@localhost test]$ tar -zxvf test111.tar.gztest111/test111/test2.txt[jly@localhost test]$ lstest111 test111.tar.gz test.tar test.txt.bz2 打包的同时使用bzip2压缩和gzip压缩有所不同，这里使用-cjvf选项来压缩。使用-jxvf选项来解压.tar.bz2格式的压缩包。 使用zip压缩zip后面先跟目录文件名（即要压缩后的自定义压缩包名），然后跟要压缩的文件或者目录。123[jly@localhost ~]$ touch 1.txt[jly@localhost ~]$ zip 1.txt.zip 1.txt adding: 1.txt (stored 0%) 当一个目录下还有二级目录甚至更多级目录时，如果想一并压缩所有文件，必须加上-r选项，如下：1[jly@localhost ~]$ zip -r dir1.zip dir1/ 解压方法：1[jly@localhost ~]$ unzip 1.txt.zip 安装更新VMware Tools 拷贝压缩包到一个地方; 解压：tar zxf vmware-linux-tools.tar.gz; 会解压出一个名为“vmware-tools-distrib”的目录; 进入上一个目录，在超级用户下使用命令./vmware-install.pl开始安装。 文本编辑工具Vimvim有三种模式：一般模式、编辑模式和命令模式。 在一般模式下不可以修改某个字符，想要修改字符，就要进入编辑模式。从一般模式进入编辑模式，你只需要按i/I/a/A/o/O/r/R中的某一个键即可。当进入编辑模式时，就会显示“插入/INSERT/REPLACE”的其中一个。 如果想从编辑模式回到一般模式，直接按esc键即可。 在一般模式下，输入“：”或者“/”即可进入命令模式。在该模式下，可以搜索某个字符或者字符串，也可以实现保存、替换、退出、显示行号等操作。 12345# vim test.txt文本内容显示如下qwqeqwqeqwqwrqrwwrwdvfvgbg# 在一般模式下，先输入\"：\"，再输入\"/qw\"，就会匹配出所有符合条件的qw。# 或者在一般模式下，先输入\"/\"，再直接输入qw，同样匹配所有qw。 命令模式的其他功能： :w : 保存文本 :q : 退出Vim :w! : 强制保存，在root用户下，即使文本只读也可以完全保存 :q! : 强制退出，所有改动不生效 :wq : 保存并退出 :set nu : 显示行号 :set nonu : 不显示行号","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"hexo博客问题","date":"2017-10-10T06:28:48.000Z","path":"2017/10/10/hexo博客问题/","text":"hexo博客中遇见的问题及解决办法。 解决fs.SyncWriteStream报错问题最近，在执行hexo命令时，遇到了这样的报错： 1(node:11320) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated. 在网上查阅资料发现，原来是node.js从8.0开始弃用fs.SyncWriteStream这个方法。有人issue了这个问题（fs.SyncWriteStream），原来是需要更新hexo-fs插件： 1npm install hexo-fs --save 但是这样我更新之后还是有同样的错误，那么就是用以下方法定位错误在哪里： 1$ hexo clean --debug 结果如图： 可以看到我所在报错的位置是hexo-deployer-git，于是找到hexo-deployer-git\\node_modules\\hexo-fs\\lib\\fs.js的第718行，将exports.SyncWriteStream = fs.SyncWriteStream;注释掉，即可。 再次使用$ hexo clean --debug，发现问题解决了： 解决Template render error问题在执行命令时，又遇到了这样的问题： 12FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) 经过查询，我知道了，有两个地方会导致出现这样的问题：①_config.yml配置文件中，你写的格式、缩进等可能会导致出现问题；②在你的page/post可能是你的哪篇文章出现了问题。 帮助文档：hexo–troubleshooting","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"CSS_齐舞","date":"2017-09-16T15:07:25.000Z","path":"2017/09/16/CSS-齐舞/","text":"参考视频：齐舞学院 层叠、继承和CSS单位选择器的特异度 选择器 内联 id个数 （伪）类个数 标签个数 特异度 #nav .list li a:link 0 1 2 2 0122 .hd ul.links a 0 0 2 2 0022 可以理解为特异度 0122 &gt; 0022，所以第一个的优先级大于第二个的优先级。 再举一个例子： 1234567&lt;article&gt; &lt;h1 class=\"title\"&gt;选择器的特异度&lt;/h1&gt;&lt;/article&gt;&lt;style&gt; .title&#123; color: blue; &#125; article h1&#123; color:red; &#125;&lt;/style&gt; 这里可以理解为.title的特异度是0010，article h1的特异度是0002。所以字体颜色是蓝色。 简单选择器的特异度级别（由低到高） level 0：* level 1：标签选择器、伪元素 level 2：类、伪类、属性 level 3：id level 4：内联 伪元素：::before,::after,::first-line,::first-letter。 伪类有：:first-child,:link,:visited,:hover,:active,:focus,:lang,:right,:left,:first。 属性匹配123456&lt;button class=\"btn\"&gt;普通按钮&lt;/button&gt;&lt;button class=\"btn btn-primary\"&gt;主要按钮&lt;/button&gt;&lt;style&gt; .btn&#123; display: inline-block;border: none;background: #e6e6e6;color: #333; &#125; .btn.btn-primary&#123; color: #fff;background: #218de6; &#125;&lt;/style&gt; 这里.btn.btn-primary会覆盖掉.btn,颜色和背景颜色为#fff和#218de6;,所以第二个按钮背景颜色为蓝色，字体颜色为白色。 important123456&lt;button class=\"btn\"&gt;普通按钮&lt;/button&gt;&lt;button class=\"btn btn-primary\"&gt;主要按钮&lt;/button&gt;&lt;style&gt; .btn&#123; display: inline-block;border: none;background: #e6e6e6;color: #333 !important; &#125; .btn.btn-primary&#123; color: #fff;background: #218de6; &#125;&lt;/style&gt; 给.btn的color属性增加了!important,那么该属性不会被改变，所以第二个按钮的背景颜色为蓝色，字体颜色为#333。 如果想要覆盖掉.btn的color值，那么也给.btn.btn-primary中的color添加!important。 Cascading（继承）某些属性会自动继承其父元素的计算值，除非显式指定一个值。 长度单位 绝对单位 px：像素，对应显示器的一个像素点 in：英寸 英寸cm：厘米 厘米mm：毫米 毫米pt：磅（1pt等于1/72英寸） 英寸pc：1pc等于12pt 相对单位 em：相对于该元素的一个font-size rem：相对于html元素的font-size vh：浏览器窗口高度的1% vw：浏览器窗口宽度的1% vmin：vh和vm中的较小值 vmax：vh和vm中的较大值 HSL颜色模型使用Hue、Saturation、Lightness三个数字来表示颜色。 Hue：色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。取值范围是0-360（0代表红色）。 Saturation：饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰。取值范围0-100%。 Lightness：越高颜色越亮。取值范围是0-100%。 例如：hsl(0,50%,50%)、hsla(120,50%,50%,0.5)。 盒模型box-sizing语法：box-sizing: border-box | content-box | inherit,初始值为content-box。 overflow语法：overflow: visible | hidden | scroll | auto,默认值为visible。 visible：默认值。内容不会被修剪，会呈现在元素框之外。 hidden：内容会被修剪，并且其余内容是不可见的。 scroll：内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto：如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 visibility语法：visible | hidden | collapse,默认值为visible。 即使不可见的元素也会占据页面上的空间。请使用 “display” 属性来创建不占据页面空间的不可见元素。 Generated Content123456789&lt;a href=\"http://example.com\"&gt;访问链接&lt;/a&gt;&lt;style&gt; a::before&#123; content: '\\2693'; &#125; a::after&#123; content: '(' attr(href) ')'; &#125;&lt;/style&gt; 排版细节vertical-align 定义盒子所处的行盒（line box）的垂直对齐关系 语法：vertical-align: baseline | sub | super | top | text-top | middle | bottom | text-bottom | &lt;percentage&gt; | &lt;length&gt; 初始值为baseline 百分比相对于元素自身的行高 box-shadowbox-shadow不再是简单的用来制造阴影效果，还可以利用它来制作小图标的一部分。 布局float,position,inline-block,table,flex,grid 水平居中 行级元素：text-align: center; 块级元素：margin: auto; 垂直居中 单行文字：line-height 行级盒子：vertical-align: middle; 绝对定位：top: 50%;left: 50%; 表格用下面的方式可以做自适应：1234567display: table /* &lt;table&gt; */display: table-cell /* &lt;td&gt; */display: table-row /* &lt;tr&gt; */display: table-column /* &lt;col&gt; */display: table-column-group /* &lt;colgroup&gt; */display: table-footer-group /* &lt;tfoot&gt; */display: table-header-group /* &lt;thead&gt; */ 举例：1234567891011&lt;nav&gt; &lt;a href=\"\"&gt;home&lt;/a&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;http&lt;/a&gt;&lt;/nav&gt;&lt;style&gt; nav&#123; width: 100%; display: table; border-collapse: collapse;line-height: 3; &#125; nav a&#123; display: table-cell; text-align: center; border: 1px solid #fff; background: #00b3ee;&#125;&lt;/style&gt; 高级选择器:target伪类可以使用:target伪类做tab选项卡功能。 12345678910111213&lt;nav&gt; &lt;a href=\"#p1\"&gt;html&lt;/a&gt; &lt;a href=\"#p2\"&gt;css&lt;/a&gt; &lt;a href=\"#p3\"&gt;javascript&lt;/a&gt;&lt;/nav&gt;&lt;p id=\"p1\"&gt;htmlhtmlhtml&lt;/p&gt;&lt;p id=\"p2\"&gt;csscsscss&lt;/p&gt;&lt;p id=\"p3\"&gt;javascriptjavascript&lt;/p&gt;&lt;style&gt; p&#123; display: none; &#125; p:target&#123; display: block; &#125;&lt;/style&gt; :lang伪类 元素匹配上指定语言时的状态 浏览器通过lang属性获得语言信息","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"《写给大家看的设计书》","date":"2017-09-13T01:06:16.000Z","path":"2017/09/13/《写给大家看的设计书》/","text":"《写给大家看的设计书》由世界著名设计师、技术专家和畅销书作家Robin Williams著。 四大设计原则 亲密性(proximity) 彼此相关的项应当靠近，归组在一起。有助于组织信息，减少混乱，为读者提供清晰的结构。 对比(contrast) 对比的基本思想：避免页面上的元素太过相似。如果元素（字体、颜色、大小、线宽、形状、空间等）不相同，那就干脆让他们截然不同。 重复(repetition) 让设计中的视觉要素在整个作品中重复出现。可以重复颜色、形状、材质、空间关系、线宽、字体、大小和图片，等等。这样一来，既能增加条理性，还可以加强统一性。 对齐(alignment) 任何东西都不能在页面随意安放。每一项都应当与页面上的某个内容存在某种视觉联系。 根本目的： 使页面统一而且有条理。 作者说 尽量不要使用居中对齐。 勇敢一点，大胆一点。打破常规对齐时不要怯懦。 但是，在打破规则之前必须清楚规则是什么。 绝对不要在页面上随意摆放元素。 找一条明确的对齐线，并坚持以它为基准。 如果两个项不完全相同，就应当使之不同，而且应当是截然不同。 颜色运用 三原色（红、黄、蓝） 三间色（橙、绿、紫） 第三色（把色轮中的空白填满得到） 互补色（色轮上相对的颜色，一种作为主色，另一种用于强调） 三色组（基色三色组、间色三色组、其他） 分裂互补三色组（从色轮的一边选择颜色，从该互补色两侧得到另外两色） 类似色（由色轮上彼此相邻的颜色组成） 暗色和亮色（纯色就是色调，向色调增加黑色就构成一个暗色，向色调增加白色就构成一个亮色） 暖色和冷色 冷色是后退型，趋于做背景色；暖色是趋进型，尽量少用暖色。 CMYK与RGB，印刷与Web CMYK代表Cyan（一种蓝色）、Magenta（一种红/粉红色）、Yellow和一个Key色（通常是黑色）。 RGB表示Red（红色）、Green（绿色）和Blue（蓝色）。 需要印刷的项目应当使用CMYK。 需要在屏幕上看的内容则应使用RGB。 字体类别字体对比有6种明确的不同方式：大小、粗细、结构、形状、方向和颜色。 Google Fonts字体网站","tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"}]},{"title":"JS几道小题","date":"2017-09-03T10:38:05.468Z","path":"2017/09/03/js几道小题/","text":"厦门实训js几道小题练习。 2017.7.6日厦门实训js作业例题1：定义两个整数变量，交换两个变量的值123456789var a = prompt(\"请输入a的值\");var b = prompt(\"请输入b的值\");var t;t = a; //t=2a = b; //a=3b = t; //b=2alert(\"交换后a的值：\" + a + \",交换后b的值：\" + b);&lt;/script&gt; 例题２：定义三个整数变量，输出一次最大值1234567891011121314var a = prompt(\"输入第一个数\");var b = prompt(\"输入第二个数\");var c = prompt(\"输入第三个数\");var max;if(a&gt;=b)&#123; max = a;&#125; else &#123; max = b;&#125;if(max&lt;c)&#123; max = c;&#125;alert(\"最大的值是：\" + max); 例题3：输入三个数从小到大的输出1234567891011121314151617181920212223242526var a = prompt(\"输入第一个数\");var b = prompt(\"输入第二个数\");var c = prompt(\"输入第三个数\");var min,max,mid;if(a&gt;=b)&#123; if(b&gt;=c)&#123; max = a;mid = b;min = c; &#125; else&#123; max = a;mid = c;min = b; &#125;&#125; else&#123; //a&lt;b if(b&gt;=c)&#123; max = b;mid = a;min = c; &#125; else&#123; max = b;mid = c;min = a; &#125;&#125;if(max&lt;c)&#123; if(a&gt;=b)&#123; max = c;mid = a;min = b; &#125; else&#123; max = c;mid = b;min = a; &#125;&#125;alert(\"从小到大排序：\" + min + \"&lt;\" + mid + \"&lt;\" + max); 额….这个写的不是很好，傻瓜式…以后再说 例题4：定义整数的成绩变量，按区间输出等级:12345678910111213141516171819202122232425262728var score = prompt(\"输入成绩：\");var sco = parseInt(score / 10);switch(sco)&#123; case 0 : alert(\"不及格！\"); break; case 1 : alert(\"不及格！\"); break; case 2 : alert(\"不及格！\"); break; case 3 : alert(\"不及格！\"); break; case 4 : alert(\"不及格！\"); break; case 5 : alert(\"不及格！\"); break; case 6: alert(\"D\"); break; case 7: alert(\"C\"); break; case 8: alert(\"B\"); break; case 9: alert(\"A\"); break; case 10: alert(\"A\"); break; default: alert(\"输入有误！\"); break;&#125; 例题5：定义一个变量表示年份，判断是否是闰年12345678&lt;!--闰年的条件是:能被4整除,但是不能被100整除,或者能被四百整除--&gt;var year = prompt(\"输入一个年份：\");if((year%4==0) &amp;&amp; (year%100!==0) || (year%400==0)) &#123; alert(year+\"年是闰年\");&#125; else &#123; alert(year+\"年是平年\");&#125; 例题6：输出100以内的质数123456789101112//2,3,5,7,11,13,17,19,23...//只能被1和自己本身除for(var n=2;n&lt;=100;n++)&#123; for(var m=2;m&lt;n;m++)&#123; if(n%m == 0)&#123; break; //跳出当前循环 &#125; &#125; if(m&gt;=n)&#123; document.write( n + \",\"); &#125;&#125; 2017.7.7日厦门实训js作业 –循环语句例题1：输出乘法口诀表123456789101112var num;for(var i=1;i&lt;10;i++)&#123; for(var j=1;j&lt;10;j++)&#123; if(j&gt;i)&#123; break; &#125; else &#123; num = i*j; document.write(j + \"*\" + i + \"=\" + num + \"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\"); &#125; &#125; document.write(\"&lt;br/&gt;\");&#125; 例题2：输出10行10列表格12345678910111213141516171819&lt;button id=\"btn\"&gt;1.点击出现表格&lt;/button&gt;&lt;table id=\"table\" cellspacing=\"0\" cellpadding=\"10\" border=\"1\"&gt;&lt;/table&gt; window.onload = function() &#123;var btn = document.getElementById(\"btn\");btn.onclick = out; function out()&#123; var table = document.getElementById(\"table\"); for(var j=1;j&lt;=10;j++)&#123; var tr = document.createElement(\"tr\"); for(var i=1;i&lt;=10;i++)&#123; var td = document.createElement(\"td\"); //创建元素节点eleNode td.innerHTML = i; tr.appendChild(td); //将元素节点td添加到tr中 &#125; table.appendChild(tr); &#125; &#125;&#125; 自己在作业的基础上拓展了一下：获取任意行列的表格并输出 12345678910111213141516171819202122请输入行数：&lt;input id=\"rows\" /&gt;&lt;br/&gt;&lt;br/&gt;请输入列数：&lt;input id=\"cols\" /&gt;&lt;br/&gt;&lt;br/&gt;&lt;button id=\"btn1\"&gt;2.点击出现你输入的表格&lt;/button&gt;&lt;br&gt;&lt;br/&gt;&lt;table id=\"table1\" cellspacing=\"0\" cellpadding=\"10\" border=\"1\"&gt;&lt;/table&gt;var btn1 = document.getElementById(\"btn1\");btn1.onclick = out1;function out1()&#123; var table1 = document.getElementById(\"table1\"); var rows = document.getElementById(\"rows\").value; var cols = document.getElementById(\"cols\").value; for(var j=1;j&lt;=cols;j++)&#123; var tr1 = document.createElement(\"tr\"); for(var i=1;i&lt;=rows;i++)&#123; var td1 = document.createElement(\"td\"); td1.innerHTML = i; tr1.appendChild(td1); &#125; table1.appendChild(tr1); &#125;&#125; 例题3：在上例表格中改变奇数行的背景12345678910111213141516171819202122&lt;button id=\"btn\"&gt;点击后奇数行有背景颜色&lt;/button&gt;&lt;table id=\"table\" border=\"1\" cellpadding=\"10px\" cellspacing=\"0\"&gt;&lt;/table&gt;window.onload = function () &#123; var btn = document.getElementById(\"btn\"); btn.onclick = out2; function out2() &#123; var table = document.getElementById(\"table\"); for (var j = 1; j &lt;= 10; j++) &#123; var tr = document.createElement(\"tr\"); if (j%2 != 0) &#123; //判断是否为奇数行 tr.style.backgroundColor = \"red\"; &#125; for (var i = 1; i &lt;= 10; i++) &#123; var td = document.createElement(\"td\"); td.innerHTML = i; tr.appendChild(td); &#125; table.appendChild(tr); &#125; &#125;&#125; 例题4：输出序列1,1,2,3,5,8,13…… N个数12345678910111213var a=1;b=1;if(a=1)&#123; document.write(a + \" \");&#125;if(b=1)&#123; document.write(b + \" \");&#125;for(var n=0;n&lt;500;n++)&#123; n = a + b; //1+1=2 ;n=2 n=3 n=5 a = b; //a=1; a=1; a=2; a=3; b = n; //b=1 b=2; b=3; b=5; ocument.write(n + \" \");&#125; 此段代码不够完善…待完善 2017.7.10日厦门实训js作业例题1：动态的显示当前时间12345678910111213141516171819202122232425function startTime()&#123; var today = new Date(); var year = today.getFullYear(); var month = today.getMonth() + 1; var day = today.getDate(); var h = today.getHours(); var m = today.getMinutes(); var s = today.getSeconds(); m = checkTime(m); s = checkTime(s); document.getElementById(\"time\").innerHTML =\"现在是北京时间：\" + year + \"年\" + month + \"月\" + day + \"日\" + \" \" + h + \":\" + m + \":\" + s ; t = setTimeout(function()&#123;startTime()&#125;,500);&#125;function checkTime(i)&#123; if(i&lt;10)&#123; i = \"0\" + i; &#125; return i;&#125; &lt;body onload=\"startTime()\"&gt; &lt;div id=\"time\"&gt;&lt;/div&gt;&lt;/body&gt; 例题2：计算器实现加减乘除（最简单的）12345678910111213141516171819202122232425262728293031323334数字1：&lt;input id=\"num1\"&gt;&lt;br/&gt;&lt;br/&gt;数字2：&lt;input id=\"num2\"&gt;&lt;br/&gt;&lt;br/&gt;&lt;button onclick=\"add()\"&gt;加法&lt;/button&gt;&lt;button onclick=\"del()\"&gt;减法&lt;/button&gt;&lt;button onclick=\"mul()\"&gt;乘法&lt;/button&gt;&lt;button onclick=\"division()\"&gt;除法&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;结果为：&lt;input id=\"result\" value=\"\"&gt;&lt;script&gt; function add() &#123; var num1 = document.getElementById(\"num1\").value; var num2 = document.getElementById(\"num2\").value; var result = parseFloat(num1) + parseFloat(num2); document.getElementById(\"result\").value = result; &#125; function del() &#123; var num1 = document.getElementById(\"num1\").value; var num2 = document.getElementById(\"num2\").value; var result = parseFloat(num1) - parseFloat(num2); document.getElementById(\"result\").value = result; &#125; function mul() &#123; var num1 = document.getElementById(\"num1\").value; var num2 = document.getElementById(\"num2\").value; var result = num1 * num2; document.getElementById(\"result\").value = result; &#125; function division() &#123; var num1 = document.getElementById(\"num1\").value; var num2 = document.getElementById(\"num2\").value; var result = num1 / num2; document.getElementById(\"result\").value = result; &#125;&lt;/script&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"WechatApp基础","date":"2017-08-24T13:50:30.000Z","path":"2017/08/24/WechatApp基础/","text":"小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。 从本地相册选择图片或使用相机拍照使用到的API是：wx.chooseImage(OBJECT) html代码：1234&lt;view bindtap=\"bindViewTap\" class=\"userinfo\"&gt; &lt;image class=\"userinfo-avatar\" src=\"&#123;&#123;avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;&lt;/view&gt; css代码：123.userinfo &#123; display: flex; flex-direction: column; align-items: center; &#125;.userinfo-avatar &#123; width: 128rpx; height: 128rpx; margin: 20rpx; border-radius: 50%; &#125;.userinfo-nickname &#123; color: #aaa; &#125; 点击部分事件处理：1234567891011121314151617data: &#123; userInfo: &#123;&#125;, avatarUrl: null&#125;, bindViewTap: function() &#123; var that = this; wx.chooseImage(&#123; count: 1, // 默认9 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) &#123; // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片 var tempFilePaths = res.tempFilePaths that.setData(&#123;avatarUrl:tempFilePaths[0]&#125;) &#125; &#125;) &#125; wx.chooseImage() 中success方法必填，其他的可选。 tempFilePaths 是图片的本地文件路径列表 文件的上传和下载使用到的API是：wx.uploadFile(OBJECT)(将本地资源上传到开发者服务器);wx.downloadFile(OBJECT)(下载文件资源到本地)。 音乐的播放和控制使用后台播放器播放音乐：wx.playBackgroundAudio(OBJECT)在onReady中使用:1234567891011121314onReady:function()&#123; wx.playBackgroundAudio(&#123; dataUrl: 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&amp;uin=346897220&amp;vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&amp;fromtag=46', success:function(res)&#123; //success &#125;, fail: function () &#123; //fail &#125;, complete: function () &#123; //complete &#125; &#125;) &#125; 暂停播放音乐：wx.pauseBackgroundAudio()添加点击事件，点击后暂停音乐：12345bindViewTap: function() &#123; wx.pauseBackgroundAudio(&#123; //暂停音乐 &#125;)&#125; 获取后台音乐播放状态：wx.getBackgroundAudioPlayerState(OBJECT)12345678910111213141516bindViewTap: function() &#123; wx.pauseBackgroundAudio(&#123; //暂停音乐 &#125;) wx.getBackgroundAudioPlayerState(&#123; success:function(res)&#123; console.log(res) &#125;, fail:function()&#123; //fail &#125;, complete:function()&#123; //complete &#125; &#125;) &#125; 在控制台打印出的效果如图： 监听音乐播放：wx.onBackgroundAudioPlay(CALLBACK)在onLoad中使用：123wx.onBackgroundAudioPlay(function()&#123; //用在：播放器写真旋转，当使用该API时，写真开始旋转&#125;) 数据缓存本地数据存储的大小限制为10MB 本地存储：wx.setStorage(OBJECT)将数据存储在本地缓存中指定的key中，会覆盖掉原来该key对应的内容，这是一个异步接口。 在onLoad中使用：1234567onLoad: function () &#123; console.log('onLoad') wx.setStorage(&#123; key: 'testKey', data: 'testValue' &#125;) &#125; 异步移除：wx.removeStorage(OBJECT)从本地缓存中异步移除指定key。 123456bindViewTap: function() &#123; wx.removeStorage(&#123; //移除 key: 'testKey', data: 'testValue' &#125;)&#125; 拓展知识：同步和异步 进程同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 进程异步：当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 同步是阻塞模式，异步是非阻塞模式。 举个例子：普通B/S模式（同步）; AJAX技术（异步） 同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回。这个期间客户端浏览器不能干任何事 异步: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕 获取当前位置(地图)获取当前的地理位置：wx.getLocation(OBJECT)在onLoad中使用：12345wx.getLocation(&#123; type: 'wgs84', //默认为wgs84返回gps坐标，gcj02返回可用于wx.openLocation的坐标 success: function (res) &#123; console.log(res) //可以在控制台看到返回的信息 &#125;) 使用微信内置地图查看位置：wx.openLocation(OBJECT)123456789101112wx.getLocation(&#123; type: 'gcj02', success: function (res) &#123; var latitude = res.latitude var longitude = res.longitude wx.openLocation(&#123; latitude: latitude, longitude: longitude, scale: 28 &#125;) &#125;&#125;) 打开地图选择位置1234567891011121314wx.getLocation(&#123; type: 'gcj02', success: function (res) &#123; var latitude = res.latitude var longitude = res.longitude wx.chooseLocation(&#123; latitude: latitude, longitude: longitude, success: function(res)&#123; console.log(res) //输出当前位置信息：经纬度等 &#125; &#125;) &#125;&#125;) 设备获取网络状态：wx.getNetworkType(OBJECT)在onLunch中使用：1234567wx.getNetworkType(&#123; success: function(res) &#123; // 返回网络类型, 有效值： // wifi/2g/3g/4g/unknown(Android下不常见的网络类型)/none(无网络) var networkType = res.networkType &#125;&#125;) 获取系统消息：wx.getSystemInfo(OBJECT)success回调参数：手机品牌、手机型号、设备像素比、屏幕宽度、屏幕高度等 12345wx.getSystemInfo(&#123; success: function(res) &#123; console.log(res) &#125;&#125;) 拨打电话：wx.makePhoneCall(OBJECT)123wx.makePhoneCall(&#123; phoneNumber: '1340000' //仅为示例，并非真实的电话号码&#125;) 动画在.wxml中使用animation1234&lt;view bindtap=\"bindViewTap\" class=\"userinfo\"&gt; &lt;image animation=\"&#123;&#123;animationData&#125;&#125;\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;&lt;/view&gt; 1234567891011121314151617181920Page(&#123; data: &#123; userInfo: &#123;&#125;, animationData: [] &#125;, //事件处理函数 bindViewTap: function() &#123; var animation = wx.createAnimation(&#123; transformOrigin: '50% 50% 0', duration: 3000, timingFunction: \"ease\", delay: 0 &#125;) animation.rotate(-180).scale(2).translate(50).step() this.setData(&#123; animationData: animation.export() &#125;)&#125; 运行效果如图：","tags":[{"name":"WechatApp","slug":"WechatApp","permalink":"http://yoursite.com/tags/WechatApp/"}]},{"title":"Flex布局","date":"2017-08-17T09:15:15.000Z","path":"2017/08/17/Flex布局/","text":"Flex是Flexible Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。 容器的属性 flex-direction该属性决定主轴的方向，即项目排列方向。 语法：flex-direction: row | row-reverse | column | column-reverse row为默认值，主轴为水平方向，起点在左端。 flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 语法：flex-wrap: nowrap | wrap | wrap-reverse nowrap为默认值，不换行；wrap换行，第一行在上方；wrap-reverse换行，第一行在下面。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content该属性定义了项目在主轴上的对齐方式。 语法：justify-content: flex-start | flex-end | center | space-between | space-around align-items该属性定义项目在交叉轴上如何对齐。 语法：align-items: flex-start | flex-end | center | baseline | stretch baseline项目的第一行文字的基线对齐;stretch为默认值，如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 语法：align-content: flex-start | flex-end | center | space-between | space-around | stretch 项目属性flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 1.item&#123; flex-grow: &lt;number&gt;; /*default 0*/ &#125; flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。(负值对该属性无效) 1.item&#123; flex-shrink: &lt;number&gt;; /*default 1*/ &#125; flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 1.item&#123; flex-basis: &lt;length&gt;; /*default auto*/ &#125; flexflex属性是flex-grow, flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。 1.item&#123; flex: none | [&lt;'flex-grow'&gt;] &lt;'&lt;flex-shrink&gt;'&gt; || &lt;'flex-basis'&gt; &#125; 该属性有两个快捷值：auto (1 1 auto)和none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关。 阮一峰 Flex布局Flex布局 实例篇","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"js几种常见排序算法","date":"2017-08-10T08:09:46.000Z","path":"2017/08/10/js几种常见排序算法/","text":"这里整理几种常用的排序，以后再加入其他的。 插入排序最普通的排序算法，把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列。 原理图： （插入操作要进行 n-1 次） 代码： 12345678910111213141516171819202122232425function insertSort(array)&#123; //假设第0个元素是一个有序的数列，第1个以后的是无序的序列， //所以从第1个元素开始将无序数列的元素插入到有序数列中 for(var i=1;i&lt;array.length;i++)&#123; if(array[i] &lt; array[i-1])&#123; //取出无序数列中的第i个作为被插入元素 var temp = array[i]; //记住有序数列的最后一个位置，并且将有序数列位置扩大一个 var j = i - 1; //比大小，找到被插入元素所在的位置 while(j &gt;= 0 &amp;&amp; temp &lt; array[j])&#123; array[j+1] = array[j]; j--; &#125; //插入 array[j+1] = temp; &#125; &#125;&#125;//var array = new Array(36,27,15,20,45,10);var array = [36,27,15,20,45,10];document.write(\"before: \" + array + \"&lt;br&gt;\");insertSort(array);document.write(\"after: \" + array); 算法分析： 最佳情况：输入数组按升序排列。T(n) = O(n) 最坏情况：输入数组按降序排列。T(n) = O(n^2) 平均情况：T(n) = O(n^2) 二分插入排序(折半插入排序)二分法插入排序是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。 原理图： （high&lt;low，查找结束，插入位置为low或high+1） 代码： 1234567891011121314151617181920212223function BinaryInsertSort(array)&#123; for(var i=1;i&lt;array.length;i++)&#123; var key = array[i]; var low = 0, high = i - 1; while(low &lt;= high)&#123; var mid = parseInt((low+high)/2); if(key&lt;array[mid])&#123; high = mid -1; &#125; else &#123; low = mid + 1; &#125; &#125; for(var j=i-1;j&gt;=low;j--)&#123; array[j+1] = array[j]; &#125; array[low] = key; //插入位置为low或high+1 &#125; return array;&#125;var array = [53,27,36,15,69,42];document.write(\"before: \" + array + \"&lt;br&gt;\");BinaryInsertSort(array);document.write(\"after: \" + array); 算法分析： 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n^2) 平均情况：T(n) = O(n^2) 冒泡排序(Bubble Sort)它重复地走访过要排序的数列，一次比较两个元素，每次遍历就将最大（或最小）值推至最前。越往后遍历查询次数越少， 跟插入排序刚好相反。 原理图： 代码： 12345678910111213141516function bubbleSort(array)&#123; for(var i=0;i&lt;array.length;i++)&#123; for(var j=array.length-1;j&gt;i;j--)&#123; if(array[j] &lt; array[j-1])&#123; var temp = array[j-1]; array[j-1] = array[j]; array[j] = temp; &#125; &#125; &#125; return array;&#125;var array = [53,27,36,15,69,42];document.write(\"before: \" + array + \"&lt;br&gt;\");bubbleSort(array);document.write(\"after: \" + array); 算法分析： 最佳情况：T(n) = O(n) 最差情况：T(n) = O(n^2) 平均情况：T(n) = O(n^2) 改进的冒泡排序如果在某次的排序中没有出现交换的情况，那么说明在无序的元素现在已经是有序了，就可以直接返回了 代码： 12345678910111213141516171819function bubbleSort(array)&#123; for(var i=0;i&lt;array.length;i++)&#123; var exchange = 0; for(var j=array.length-1;j&gt;i;j--)&#123; if(array[j] &lt; array[j-1])&#123; //使较小的元素浮在上面 var temp = array[j-1]; array[j-1] = array[j]; array[j] = temp; exchange = 1; &#125; &#125; if(!exchange) return array; &#125; return array;&#125;var array = [53,27,36,15,69,42];document.write(\"before: \" + array + \"&lt;br&gt;\");bubbleSort(array);document.write(\"after: \" + array); 快速排序在数据集之中，选择一个元素作为”基准”（pivot）。 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 原理图： 代码： 123456789101112131415161718var array = [36,53,27,20,15,69,42]; document.write(\"before: \" + array + \"&lt;br&gt;\"); function quickSort(array)&#123; if (array.length &lt;= 1) &#123;return array&#125;; var pivotIndex = Math.floor(array.length / 2); //pivot基准 var pivot = array.splice(pivotIndex,1); var left = []; var right = []; for (var i = 0; i &lt; array.length; i++)&#123; if(array[i] &lt; pivot) &#123; left.push(array[i]); &#125; else &#123; right.push(array[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right)); &#125; document.write(\"after: \" + quickSort(array)); 算法分析： 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n^2) 平均情况：T(n) = O(nlogn) 选择排序在无序区中选出最小的元素，然后将它和无序区的第一个元素交换位置。 原理图： 代码： 123456789101112131415161718function selectSort(array) &#123; for(var i=0;i&lt;array.length;i++)&#123; var min = array[i]; for(var j = i+1;j&lt;array.length-1;j++)&#123; if(min &gt; array[j])&#123; var temp = min; min = array[j]; array[j] = temp; &#125; &#125; array[i] = min; &#125; return array;&#125;var array = [53,27,36,15,69,42];document.write(\"before: \" + array + \"&lt;br&gt;\");selectSort(array);document.write(\"after: \" + array); 算法分析： 最佳情况：T(n) = O(n^2) 最差情况：T(n) = O(n^2) 平均情况：T(n) = O(n^2) 参考资料知乎-浅谈前端博客园-9种排序算法","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"正则表达式","date":"2017-08-08T11:33:30.000Z","path":"2017/08/08/正则表达式/","text":"正则表达式是对字符串操作的一种逻辑公式。 为什么使用正则表达式? 测试字符串内的模式 替换文本 基于模式匹配从字符串中提取子字符串 限定符 字符 描述 + 匹配前面的子表达式至少一次 * 匹配前面的子表达式零次或多次 ? 匹配前面的子表达式零次或一次 {n} n是一个非负整数,匹配确定的n次 {n,} n是一个非负整数,至少匹配n次 {n,m} m和n均为非负整数,其中n&lt;=m,最少匹配n次且最多匹配m次 *、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 例如，您可能搜索HTML文档，以查找括在H1标记内的章节标题。该文本在您的文档中如下： &lt;H1&gt;Chapter 1 - 介绍正则表达式&lt;/H1&gt; 贪婪： 下面的表达式匹配从开始小于符号(&lt;)到关闭H1标记的大于符号(&gt;)之间的所有内容： /&lt;.*&gt;/ 非贪婪： 如果您只需要匹配开始和介绍H1标记，下面的非贪婪表达式只匹配&lt;H1&gt;： /&lt;.*?&gt;/ 如果只想匹配开始的H1标签，表达式则是： /&lt;\\w+?&gt;/ 通过在*、+或?限定符之后放置?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。 定位符 字符 描述 ^ 匹配输入字符串开始的位置 $ 匹配输入字符串结尾的位置 \\b 匹配一个字边界，即字与空格间的位置 \\B 非字边界匹配 注意： 不能将限定符与定位符一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如^*之类的表达式。 运算符优先级下表从最高到最低说明了各种正则表达式运算符的优先级顺序： 运算符 描述 \\ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \\任何元字符、任何字符 定位点和序列(即：位置和顺序) I 替换，”或”操作 for example例1： 查找重复的单词 123var str = 'Is is the cost of of gasoline going up up';patt1 = /\\b([a-z]+) \\1\\b/gi;document.write(str.match(patt1)); //输出：Is is,of of,up up 解析： [a-z]+ 包含最少一个字母。\\1 指定第一个子匹配项。字边界元字符\\b确保只检测整个单词，否则，诸如 “is issued” 或 “this is” 之类的词组将不能正确地被此表达式识别。正则表达式后面的全局标记g指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。i标记指定不区分大小写。 例2： 分解URL 1234567var str = \"http://www.runoob.com:80/html/html-tutorial.html\";var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/;arr = str.match(patt1);for (var i = 0; i &lt; arr.length ; i++) &#123; document.write(arr[i]); document.write(\"&lt;br&gt;\");&#125; 解析： 这里分解为四个括号()来看。 第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。(“http”) 第二个括号子表达式捕获地址的域地址部分。子表达式匹配 / 和 : 之外的一个或多个字符。(“www.runoob.com”) 第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。(“:80”) 第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。(“/html/html-tutorial.html”) 例3： 一个小写字母和一位数字组成的字符串 /^[a-z][0-9]$/ 比如，z2,a4；但不能是ab2,r2d4。 例4： 第一个字符串不能是数字 /^[^0-9][0-9]$/ 这个模式与&amp;5,g7,-2是匹配的，但与12,66不是匹配的。下面是几个排除特定字符的例子： /[^a-z]/ //除了小写字母以外的所有字符 /[^\\\\\\/\\^]/ //除了(\\)(/)(^)之外的所有字符 /[^\\&quot;\\&apos;] //除了双引号(&quot;)和单引号(&apos;)之外的所有字符 例5： 更多的单词和数字 1234/^[a-zA-Z0-9_]&#123;1,&#125;$/ //所有包含一个以上的字母、数字或下划线的字符串/^[1-9][0-9]&#123;0,&#125;$/ //所有的正整数/^\\-&#123;0,1&#125;[0-9]&#123;1,&#125;$/ //所有的整数/^[-]?[0-9]+\\.?[0-9]+$/ //所有的浮点数 解释下上面的第4条：以一个可选的负号([-]?) 开头(^)、跟着一个或更多的数字([0-9]+)、和一个小数点(.) 再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。 由于特殊字符? 和 {0,1} 是相等的，它们都代表着：0个或1个前面的内容 或 前面的内容是可选的。所以上面第四条可以简化为： /^\\-?[0-9]{1,}\\.?[0-9]{1,}$/ 特殊字符* 和 {0,} 是相等的，它们代表着：0个或多个前面的内容 。 特殊字符+ 和 {1,} 是相等的，它们代表着：1个或多个前面的内容 。所以上面的4条可以改为： 1234/^[a-zA-Z0-9_]+$//^[1-9][0-9]*$//^\\-?[0-9]+$//^\\-?[0-9]+\\.?[0-9]+$/ 例6： 字符匹配 /a.c/ 可以匹配出的结果有aac,abc,acc,a4c,a#c等等。 常用正则表达式1.检验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 2.检测字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 3.特殊需求表达式 Email地址：^[a-z0-9]+([._\\-][a-z0-9])@([a-z0-9]+[-a-z0-9]*[a-z0-9]+.){1,63}[a-z0-9]+$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?|&lt;.? /&gt; ( 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 正则表达式教程–菜鸟教程JavaScript RegExp 对象–W3school","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"JavaScript手册","date":"2017-08-05T14:51:43.000Z","path":"2017/08/05/JavaScript手册/","text":"JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。 Event对象之事件句柄(Event Handlers)onload &amp; onunload事件是在用户进入或者离开页面的时候被触发。onload事件可用于检测访问者的浏览器类型和浏览器版本;onload和onunload事件可用于处理cookie。 123456789&lt;body onload=\"checkCookies()\"&gt;function checkCookies() &#123; if(navigator.cookieEnabled = true)&#123; alert(\"Cookies可用\"); &#125; else &#123; alert(\"不可用\"); &#125;&#125;&lt;/body&gt; onchange事件在域的内容改变时发生。常结合对输入字段的验证来使用。 支持该事件的HTML标签：&lt;input type=&quot;text&quot;&gt; , &lt;select&gt; , &lt;textarea&gt; ; 支持该事件的JavaScript对象：fileUpload , select , text , textarea; 1234567输入你的名字：&lt;input type=\"text\" id=\"name\" onchange=\"myFunction()\"&gt;&lt;p&gt;当你离开输入框后，函数将被触发，将小写字母转为大写字母。&lt;/p&gt;function myFunction() &#123; var name = document.getElementById(\"name\"); name.value = name.value.toUpperCase();&#125; onmouseover &amp; onmouseout事件用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。 12345678&lt;div onmouseover=\"mOver(this)\" onmouseout=\"mOut(this)\" style=\"background: red;width: 120px;height: 120px;\"&gt;&lt;/div&gt;function mOut(obj) &#123; obj.innerHTML = \"Move Over Me\";&#125;function mOver(obj) &#123; obj.innerHTML = \"Thank you!\";&#125; onmousedown &amp; onmouseup &amp; onclick事件onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。 1234&lt;img id=\"img\" onmousedown=\"lighton()\" onmouseup=\"lightoff()\" src=\"http://www.runoob.com/try/demo_source/bulboff.gif\" width=\"100px\" height=\"180px\"&gt;function lightoff() &#123; document.getElementById('img').src=\"http://www.runoob.com/try/demo_source/bulboff.gif\";&#125; button事件指示当事件被触发时哪个鼠标按键被点击。语法：event.button = 0|1|2 。 参数 描述 0 规定鼠标左键 1 规定鼠标中键 2 规定鼠标右键 123456789101112&lt;body onmousedown=\"whichbutton(event)\"&gt;&lt;p&gt;click in the document!&lt;/p&gt;&lt;script&gt; function whichbutton(event) &#123; if(event.button == 2)&#123; alert(\"you click the right mouse button!\"); &#125; else &#123; alert(\"you click the left mouse button!\"); &#125; &#125;&lt;/script&gt;&lt;/body&gt; clientX &amp; clientY事件返回当事件被触发时鼠标指针向对于浏览器页面（或客户区：当前窗口）的水平坐标或者是垂直坐标。 12345678910&lt;body onmousedown=\"showCoords(event)\"&gt;&lt;p&gt;click in the document!&lt;/p&gt;&lt;script&gt; function showCoords(event) &#123; x = event.clientX; y = event.clientY; alert(\"X coords: \" + x + \",Y coords: \" + y); &#125;&lt;/script&gt;&lt;/body&gt; screenX &amp; screenY事件返回事件发生时鼠标指针相对于屏幕的水平坐标或者是垂直坐标。 DOM Element对象node.appendChild(node)向节点添加最后一个子节点: 12345678910&lt;ul id=\"myList\"&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;&lt;button onclick=\"myfunction()\"&gt;点击&lt;/button&gt;&lt;script&gt; function myfunction() &#123; var node = document.createElement(\"li\"); var textnode = document.createTextNode(\"water\"); node.appendChild(textnode); document.getElementById(\"myList\").appendChild(node); &#125;&lt;/script&gt; 从一个列表向另一个列表中移动列表项： 123456789&lt;ul id=\"myList1\"&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;&lt;ul id=\"myList2\"&gt;&lt;li&gt;water&lt;/li&gt;&lt;li&gt;milk&lt;/li&gt;&lt;/ul&gt;&lt;button onclick=\"myfunction()\"&gt;点击&lt;/button&gt;&lt;script&gt; function myfunction() &#123; var node = document.getElementById(\"myList2\").firstChild; document.getElementById(\"myList1\").appendChild(node); &#125;&lt;/script&gt; node.attributes返回指定节点的属性集合，即NamedNodeMap: 1234567&lt;button id=\"btn\" onclick=\"myFunction()\" class=\"btn\"&gt;点击&lt;/button&gt;&lt;script&gt; function myFunction() &#123; var x = document.getElementById(\"btn\").attributes.length; document.write(x); &#125;&lt;/script&gt; //输出结果：3 element.childNodes返回元素子节点的NodeList。 node.cloneNode(deep)创建节点的拷贝，并返回该副本。克隆所有属性以及它们的值。如果您需要克隆所有后代，请把deep参数设置true，否则设置为false。 123456789&lt;ul id=\"myList1\"&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;&lt;ul id=\"myList2\"&gt;&lt;li&gt;water&lt;/li&gt;&lt;li&gt;milk&lt;/li&gt;&lt;/ul&gt;&lt;button onclick=\"myFunction()\"&gt;点击&lt;/button&gt;&lt;script&gt;function myFunction() &#123; var clone = document.getElementById(\"myList2\").lastChild.cloneNode(true); document.getElementById(\"myList1\").appendChild(clone);&#125;&lt;/script&gt; node.insertBefore(newnode,existingnode)在已有子节点之前插入新的子节点: 123456789101112&lt;ul id=\"myList\"&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;&lt;button onclick=\"myFunction()\"&gt;点击&lt;/button&gt;&lt;script&gt;function myFunction() &#123; var newItem = document.createElement('li'); var textnode = document.createTextNode('water'); newItem.appendChild(textnode); var list = document.getElementById('myList'); list.insertBefore(newItem,list.childNodes[0]);&#125;&lt;/script&gt; node.nextSibling返回指定节点之后紧跟的节点，在相同的树层级中: 123&lt;ul id='myList'&gt;&lt;li id='item1'&gt;coffee&lt;/li&gt;&lt;li id='item2'&gt;tea&lt;/li&gt;&lt;/ul&gt;x = document.getElementById('item1').nextSibling.id;document.write(x); //输出：item2 node.parentNode以Node对象的形式返回指定节点的父节点: 123&lt;ul&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;tea&lt;/li&gt;&lt;/ul&gt;x = document.getElementsByTagName('li')[0];document.write(x.parentNode.nodeName); //输出：UL Array对象concat() –连接连接两个或更多的数组，并返回结果。如果要进行concat()操作的参数是数组，那么添加的是数组中的元素，而不是数组。 12345var color = [\"Red\",\"Green\",\"Blue\"];var name = [\"Luya\",\"Awebone\"];var kei = [\"Robin\"];document.write(color.concat(name,kei));//输出：Red,Green,Blue,Luya,Awebone,Robin shift() &amp; pop() –删除shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 1234var color = [\"Red\",\"Green\",\"Blue\"];document.write(color+\"&lt;br&gt;\"); //输出：Red,Green,Bluedocument.write(color.shift()+\"&lt;br&gt;\"); //输出：Reddocument.write(color); //输出：Green,Blue pop()方法用于删除数组的最后一个元素并返回删除的元素。 1234var color = [\"Red\",\"Green\",\"Blue\"];document.write(color+\"&lt;br&gt;\"); //输出：Red,Green,Bluedocument.write(color.pop()+\"&lt;br&gt;\"); //输出：Bluedocument.write(color); //输出：Red,Green unshift() &amp; push() –增加unshift()方法可向数组的开头添加一个或更多元素，并返回新的长度。 123var color = [\"Red\",\"Green\",\"Blue\"];color.unshift(\"hello\",\"world\");document.write(color); //输出：hello,world,Red,Green,Blue push()方法可向数组的末尾添加一个或多个元素，并返回新的长度。 123var color = [\"Red\",\"Green\",\"Blue\"];color.push(\"hello\",\"world\");document.write(color); //输出：Red,Green,Blue,hello,world splice() –插入,删除,替换语法：array.splice(index,howmany,item1,...,itemX) index必须，规定从何处添加或删除元素；howmany必须，规定应该删除多少元素，必须为数字，可以为“0”，若为规定此参数，则删除从index开始到原数组结尾的所有元素；item可选，要添加到数组的新元素。 123var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];color.splice(2,0,\"luya\",\"awebone\");document.write(color); //输出：Red,Green,luya,awebone,Blue,pink 123var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];color.splice(2,1,\"luya\");document.write(color); //输出：Red,Green,luya,pink reverse() –颠倒reverse()方法用于颠倒数组中元素的顺序。 123var color = [\"Red\",\"Green\",\"Blue\"];document.write(color.reverse());//输出：Blue,Green,Red copyWithin() –拷贝copyWithin()方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中。 语法：array.copyWithin(target,start,end) target必须，从该位置开始替换数据；start必须，从该位置开始读取数据，默认为 0 。如果为负值，表示倒数；end可选，停止复制的索引位置(默认为array.length)。 1234567var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];document.write(color.copyWithin(0,1)+\"&lt;br&gt;\"); //Green,Blue,pink,pinkdocument.write(color.copyWithin(1,1)+\"&lt;br&gt;\"); //Red,Green,Blue,pinkdocument.write(color.copyWithin(2,1)+\"&lt;br&gt;\"); //Red,Green,Green,Bluedocument.write(color.copyWithin(3,1)+\"&lt;br&gt;\"); //Red,Green,Blue,Greendocument.write(color.copyWithin(2,3)+\"&lt;br&gt;\"); //Red,Green,pink,pink//上边的document要一条一条的输出，一起输出结果会变 sort() –排序sort()方法用于对数组的元素进行排序。排序顺序可以是字母或数字，并按升序或降序。默认排序顺序为按字母升序。 注意： 当数字是按字母顺序排列时”40”将排在”5”前面；使用数字排序，你必须通过一个函数作为参数来调用。 12var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];document.write(color.sort()); //输出：Blue,Green,Red,pink 数字排序(升序): 123var points = [40,20,1,5,12,23];points.sort(function (a,b)&#123; return a-b; &#125;);document.write(points); //输出：1,5,12,20,23,40 若要实现数字降序则改为：return b-a 。 some() –检测some()方法用于检测数组中的元素是否满足指定条件(函数提供)。会依次执行数组的每个元素，如果有一个元素满足条件，就返回true,剩下的元素不会在执行检测；如果没有满足条件的元素，则返回false。 12345var ages = [3,10,18,20];function check(age) &#123; return age &gt;= 18;&#125;document.write(ages.some(check)); //输出：true map() –处理map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 注意： some()和map()都不会对空数组进行检测。 12var num = [1,4,16,100];document.write(num.map(Math.sqrt)); //输出：1,2,4,10 join() –转换join()方法用于把数组中的所有元素转换一个字符串，元素是通过指定的分隔符进行分隔的。 12var color = [\"Red\",\"Green\",\"Blue\"];document.write(color.join(\" and \")); //输出：Red and Green and Blue fill() –填充fill()方法用于将一个固定值替换数组的元素。 语法：array.fill(value,start,end) 12var color = [\"Red\",\"Green\",\"Blue\"];document.write(color.fill(\"and\")); //输出：and,and,and 12var color = [\"Red\",\"Green\",\"Blue\",\"pink\"];document.write(color.fill(\"and\",1,3)); //输出：Red,and,and,pink filter()filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 12345var ages = [32,15,18,7,39];function check(age)&#123; return age &gt;= 18;&#125;document.write(ages.filter(check)); //输出：32,18,39 菜鸟教程JavaScript Array对象 Date对象所有浏览器都支持date的各种方法。 123var d = new Date();//var d = new Date(year,month);document.write(d.getDate()); 方法 描述 备注 getDate() 返回一个月中的某一天 (1~31) / getDay() 返回一周中的某一天 (0~6) 周日是0，周一是1，依次类推 getFullYear() 返回一个表示年份的4位数字 / getMonth() 返回月份(0~11) 0(一月)到11(十二月) getHours() 返回Date对象的小时(0~23) 0表示(午夜) getMinutes() 返回Date对象的分钟(0~59) / getSeconds() 返回Date对象的秒数(0~59) / getMilliseconds() 返回Date对象的毫秒(0~999) / getTime() 返回1970年1月1日至今的毫秒数 / parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数 / setDate() 设置一个月的某一天 其他的方法类似，这里就不一一列举 toDateString() 把Date对象的日期部分转换为字符串 输出：Fri Aug 04 2017 toLocaleDateString() 根据本地时间格式，把Date对象的日期部分转换为字符串 输出：2017/8/4 toLocaleTimeString() 根据本地时间格式，把Date对象的时间部分转换为字符串 输出：上午10:59:41 toLocaleString() 据本地时间格式，把Date对象转换为字符串 输出：2017/8/4 上午11:00:36 setDate()方法: 123var d = new Date();d.setDate(15);document.write(d); //今天真是的是4号，输出：Tue Aug 15 2017 10:54:13 GMT+0800 (中国标准时间) getFullYear()方法： 12var d = new Date();document.write(d.getFullYear()); //输出：2017 getHours()方法： 12var d = new Date(\"July 21,2017 21:00:00\");document.write(d.getHours()); //输出：21 菜鸟教程JavaScipt Date对象 Math对象floor(x)对x进行下舍入，返回小于等于x的最大整数： 1document.write(Math.floor(1.6)); //输出：1 ceil(x)对x进行上舍入，返回大于等于x的最大整数： 1document.write(Math.ceil(1.4)); //输出：2 round(x)对x进行四舍五入： 1document.write(Math.round(1.4)); //输出：1 random()返回介于 0(包含) ~ 1(不包含) 之间的一个随机数： 12345678&lt;p id=\"demo\"&gt;点击按钮随机显示1到10之间的随机数：&lt;/p&gt;&lt;button onclick=\"myFunction()\"&gt;点击&lt;/button&gt;&lt;script&gt;function myFunction() &#123; var demo = document.getElementById(\"demo\"); demo.innerHTML = Math.floor(Math.random() * 10 + 1);&#125;&lt;/script&gt; max(x,y,…,n) &amp; min()max()返回两个指定的数中带有较大的值的那个数: 1document.write(Math.max(1,56,4,22,-8)); //输出：56 菜鸟教程JavaScipt Math对象 String对象substring() &amp; slice() &amp; substr() –提取substring()用于提取字符串中介于两个指定下标之间的字符: 语法：stringObject.substring(start,stop) 123var str=\"Hello world!\"document.write(str.substring(3)); //输出：lo world!document.write(str.substring(3,7)); //输出：lo w slice()可提取字符串的某个部分，并以新的字符串返回被提取的部分: 语法：stringObject.slice(start,end) 123var str=\"Hello happy world!\"document.write(str.slice(6)); //输出：happy world!document.write(str.slice(6,11)); //输出：happy substr()可在字符串中抽取从 start 下标开始的指定数目的字符: 语法：stringObject.substr(start,length) 123var str=\"Hello world!\"document.write(str.substr(3)); //输出：lo world!document.write(str.substr(3,7)); //输出：lo worl indexOf()返回某个指定的字符串值在字符串中首次出现的位置。对大小写敏感；如果要检索的字符串值没有出现，则该方法返回-1。 12345var str=\"Hello world!\"document.write(str.indexOf(\"Hello\") + \" \");document.write(str.indexOf(\"World\") + \" \");document.write(str.indexOf(\"world\"));//输出： 0 -1 6 RegExp对象RegExp对象表示正则表达式，它是对字符串执行模式匹配的强大工具。 直接量语法：/pattern/attributes 修饰符 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配(查找所有匹配而非在找到第一个匹配后停止) m 执行多行匹配 123var str = \"Visit W3School\";var patt1 = /w3school/i;document.write(str.match(patt1)); //输出：W3School 123var str=\"Is this all there is?\";var patt1=/is/gi;document.write(str.match(patt1)); //输出：Is,is,is 方括号 [abc]表达式：用于查找方括号之间的任何字符,方括号内的字符可以是任何字符或字符范围。 直接量语法：/[abc]/ 123var str = \"Is this all there is?\";var patt1 = /[a-h]/g;document.write(str.match(patt1)); //输出：h,a,h,e,e [^abc]：用于查找任何不在方括号之间的字符。 [0-9]：查找任何从0至9的数字。 [a-z]：查找任何从小写a到小写z的字符。 (red|blue|green)：查找任何指定的选项。 元字符 . : 查找单个字符，除了换行和行结束符。 12var str = \"That's hot!\";document.write(str.match(/h.t/g)); //输出：hat,hot \\w : 查找单词字符。单词字符包括：a-z、A-Z、0-9，以及下划线。 12var str = 'Give 100%!';document.write(str.match(/\\w/g)); //输出：G,i,v,e,1,0,0 \\W : 查找非单词字符。（上面的代码输出：%） \\d &amp; \\D : 查找数字/查找非数字字符。 \\s &amp; \\S : 查找空白字符/查找非空白字符。空白字符可以是： 空格符 (space character) 制表符 (tab character) 回车符 (carriage return character) 换行符 (new line character) 垂直换行符 (vertical tab character) 换页符 (form feed character) \\b : 匹配单词边界。在单词边界匹配的位置，单词字符后面或前面不与另一个单词字符直接相邻。请注意，匹配的单词边界并不包含在匹配中。换句话说，匹配的单词边界的长度为零。（不要与[\\b]混淆。）如果未找到匹配，则返回null。 注意：\\b元字符通常用于查找位于单词的开头或结尾的匹配。 例子： 1./\\bm/ 匹配 “moon” 中的 ‘m’,返回m； 2./oo\\b/ 不匹配 “moon” 中的 ‘oo’，因为 ‘oo’ 后面的 ‘n’ 是一个单词字符，返回null； 3./oon\\b/ 匹配 “moon” 中的 ‘oon’，因为 ‘oon’ 位于字符串的末端，后面没有单词字符，返回oon； 4./\\w\\b\\w/ 不匹配任何字符，因为单词字符之后绝不会同时紧跟着非单词字符和单词字符，返回null。 \\B : 匹配非单词边界。匹配位置的上一个和下一个字符的类型是相同的：即必须同时是单词，或必须同时是非单词字符。字符串的开头和结尾处被视为非单词字符。如果未找到匹配，则返回null 注意：\\B元字符通常用于查找不处在单词的开头或结尾的匹配。 \\n : 查找换行符。返回换行符被找到的位置。如果未找到匹配，则返回-1。 量词 n+ : 匹配包含至少一个n的任何字符串。 12var str = 'Hellooo World! Hello W3School!';document.write(str.match(/o+/g)); //输出：ooo,o,o,oo n* : 匹配包含零个或多个n的任何字符串。 例： 对l进行全局搜索，包括其后紧跟的一个或多个o： 12var str = 'Hellooo World! Hello W3School!';document.write(str.match(/lo*/g)); //输出：l,looo,l,l,lo,l n? : 匹配任何包含零个或一个n的字符串。 例： 对1进行全局搜索，包括其后紧跟的零个或一个0： 12var str = '1,100 or 1000';document.write(str.match(/10?/g)); //输出：1,10,10 n{x} : 匹配包含X个n的序列的字符串。 例： 对包含四位数字序列的子串进行全局搜索： 12var str = '100,1000 or 10000';document.write(str.match(/\\d&#123;4&#125;/g)); //输出：1000,1000 n{x,Y} : 匹配包含X至Y个n的序列的字符串。X和Y必须是数字。 例： 对包含三位至四位数字序列的子串进行全局搜索： 12var str = '100,1000 or 10000';document.write(str.match(/\\d&#123;3,4&#125;/g)); //输出：100,1000,1000 n{x,} : 匹配包含至少X个n的序列的字符串。 例： 对包含至少三位数字序列的子串进行全局搜索： 12var str = '100,1000 or 10000';document.write(str.match(/\\d&#123;3,4&#125;/g)); //输出：100,1000,1000 n$ : 匹配任何结尾为n的字符串。 例： 对字符串结尾的 “is” 进行全局搜索： 12var str = 'Is this his';document.write(str.match(/is$/g)); //输出：is ^n : 匹配任何开头为n的字符串。 例： 对字符串开头的 “is” 进行全局搜索： 12var str = 'Is this his';document.write(str.match(/^is/g)); //输出：Is ?=n : 匹配任何其后紧接指定字符串n的字符串。 例： 对其后紧跟 “all” 的 “is” 进行全局搜索： 123var str = 'Is this all there is';patt1 = /is(?=all)/;document.write(str.match(patt1)); //输出：is ?!n : 匹配其后没有紧接指定字符串n的任何字符串。 例： 对其后没有紧跟 “all” 的 “is” 进行全局搜索： 123var str = 'Is this all there is';patt1 = /is(?! all)/gi;document.write(str.match(patt1)); //输出：Is,is 定位符 ^ : 匹配输入字符串开始的位置。 $ : 匹配输入字符串结尾的位置。 RegExp对象方法 compile : 编译正则表达式。 exec : 检索字符串中指定的值。返回找到的值，并确定其位置。 test : 检索字符串中指定的值。返回true或false。 支持正则表达式的String对象的方法 search()用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 match()在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 replace()在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 split()把一个字符串分割成字符串数组。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"二叉树","date":"2017-08-03T10:48:00.000Z","path":"2017/08/03/二叉树/","text":"二叉树（Binary Tree）是n（n&gt;=0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。二叉树中每一个节点都是一个对象，每一个数据节点都有三个指针，分别是指向父母、左孩子和右孩子的指针。每一个节点都是通过指针相互连接的。相连指针的关系都是父子关系。 二叉树节点的定义12345struct binaryTreeNode&#123; int m_nValue; binaryTreeNode* m_pLeft; binaryTreeNode* m_pRight;&#125;; 五种基本形态 空二叉树 只有一个根节点 根节点只有左子树 根节点只有右子树 根节点既有左子树又有右子树 又： 拥有三个节点的普通树只有两种情况：2层或3层。但由于二叉树要分左右，于是就有了如图5种情况： 特殊二叉树 斜树 上图的第二、三个小树。 满二叉树 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树 完全二叉树是指最后一层左边是满的，右边可能满也可能不满，然后其余层都是满的。一个深度为k，节点个数为 2^k - 1 的二叉树为满二叉树（完全二叉树）。就是一棵树，深度为k，并且没有空位。 特点： 叶子结点只能出现在最下两层。 最下层的叶子一定集中在左部连续位置。 倒数第二层，若有叶子结点，一定都在右部连续位置。 如果结点度为1，则该结点只有左孩子。 同样结点树的二叉树，完全二叉树的深度最小。 性质 在二叉树的第i层上至多有2^(i-1)个结点(i&gt;=1) 深度为k的二叉树至多有2^k-1个结点(k&gt;=1) 各遍历特性 前序遍历 访问根节点 前序遍历左子树 前序遍历右子树 中序遍历 中序遍历左子树 访问根节点 中序遍历右子树 后序遍历 后序遍历左子树 后序遍历右子树 访问根节点 由二叉树得各遍历 先序遍历: ABDGCEF ; 中序遍历: DGBAECF ; 后序遍历: GDBEFCA ; 已知前序、中序遍历，求后序遍历 例： 前序遍历： GDAFEMHZ 中序遍历： ADEFGHMZ 解析: 1.根据前序遍历的特点，得到根节点是 G ; 2.观察中序遍历，知：ADEF是根节点的左子树，HMZ是根节点的右子树; 3.接下来，知道左子树的根节点为 D ; 4.同理，A 为 D 的左子树，EF 为右子树 5.右子树的根节点是 M ，依次，画出的结果如图： 那么，可以得到后序遍历顺序为：AEFDHZMG 已知中序、后序遍历，求前序遍历 例： 中序遍历: ADEFGHMZ 后序遍历: AEFDHZMG 解析： 1.由后序遍历知 G 为根节点,结合中序遍历知 ADEF 为左子树，HMZ 为右子树; 2.再观察后序遍历，知道 D 为左子树根节点， M 为右子树根节点; 3.分析结果如图：","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"jQuery手册","date":"2017-07-28T15:09:06.000Z","path":"2017/07/28/jQuery手册/","text":"jQuery是一个JavaScript函数库，极大的简化了JavaScript编程。 jQuery 版本 2 以上不支持 IE6、7、8 浏览器。如果需要支持 IE6/7/8，那么请选择1.9。你还可以通过条件注释在使用 IE6/7/8 时只包含进1.9。 &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;jquery-1.9.0.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;!--[if gte IE 9]&gt;&lt;!--&gt; &lt;script src=&quot;jquery-2.0.0.js&quot;&gt;&lt;/script&gt; &lt;!--&lt;![endif]--&gt; 添加jQuery： 官网下载 可以直接从百度CDN中引用jQuery：src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot; 语法文档就绪事件： $(document).ready(function(){ //代码部分 }); 这是为了防止文档在完全加载之前运行jquery代码。 选择器 语法 描述 $(“p”) 元素选择器 $(“#id”) id选择器 $(“.class”) class选择器 层级选择器 事件什么是事件？页面对不同访问者的响应叫做事件。 常用事件方法1.$(document).ready()2.click() &amp; dblclick()3.bind()将事件和函数绑定到元素上。为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数。 $(&quot;button&quot;).bind(&quot;click&quot;,function(){ $(&quot;p&quot;).show(); }); 4.on() &amp; off()在被选元素及子元素上添加一个或多个事件处理程序。使用on()方法添加的事件处理程序适用于当前及未来的元素（比如由脚本创建的新元素）。 $(&quot;p&quot;).on(&quot;click&quot;,function(){ alert(&quot;The paragraph was clicked.&quot;); }); 提示：如需移除事件处理程序，使用off()方法 $(&quot;button&quot;).click(function(){ $(&quot;p&quot;).off(&quot;click&quot;); }); 向元素添加多个事件处理程序： $(&quot;p&quot;).on({ mouseover:function(){$(&quot;body&quot;).css(&quot;background-color&quot;,&quot;lightgray&quot;);}, mouseout:function(){$(&quot;body&quot;).css(&quot;background-color&quot;,&quot;lightblue&quot;);}, click:function(){$(&quot;body&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);} }); 5.toggle()用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的click事件。 &lt;button&gt;请点击这里，来切换不同的背景颜色&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).toggle(function(){ $(&quot;body&quot;).css(&quot;background&quot;,&quot;green&quot;);} ,function(){ $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;red&quot;);} ,function(){ $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);} ); }); 6.mousedown() &amp; mouseup()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生mousedown事件: $(&quot;button&quot;).mousedown(function(){ $(&quot;p&quot;).slideToggle(); }); 当在元素上松开鼠标按钮时，会发生mouseup事件 7.focus() &amp; blur()当元素获得焦点时，发生focus事件;当元素失去焦点时发生blur事件: &lt;input type=&quot;text&quot; /&gt; $(&quot;input&quot;).focus(function(){ $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;#FFFFCC&quot;); }); $(&quot;input&quot;).blur(function(){ $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;#D6D6FF&quot;); }); 8.hover()光标悬停事件: $(&quot;p&quot;).hover(function(){ $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); },function(){ $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;pink&quot;); }); 9.1. event.targettarget属性规定哪个DOM元素触发了该事件: &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;h2&gt;这是另一个标题&lt;/h2&gt; &lt;p&gt;这是一个段落&lt;/p&gt; &lt;div&gt;&lt;/div&gt; $(&quot;p,h1,h2&quot;).click(function(event){ $(&quot;div&quot;).html(&quot;点击事件由一个 &quot; + event.target.nodeName + &quot; 元素触发&quot;); }); 9.2. event.pageX &amp; event.pageYpageX()属性是鼠标指针的位置，相对于文档的左边缘;pageY()属性是鼠标指针的位置，相对于文档的上边缘: &lt;p&gt;鼠标指针位于：&lt;span&gt;&lt;/span&gt;&lt;/p&gt; $(document).mousemove(function(e){ $(&quot;span&quot;).text(&quot;X:&quot; + e.pageX + &quot;,Y:&quot; + e.pageY); }) 10.trigger()触发被选元素的指定事件类型: &lt;input type=&quot;text&quot; name=&quot;FirstName&quot; value=&quot;Hello World&quot; /&gt; &lt;br/&gt; &lt;button&gt;激活input域的select事件&lt;/button&gt; $(&quot;input&quot;).select(function(){ $(&quot;input&quot;).after(&quot;文本被选中！&quot;); }); $(&quot;button&quot;).click(function(){ $(&quot;input&quot;).trigger(&quot;select&quot;); }); 使用Event对象来触发事件： $(&quot;input&quot;).select(function(){ $(&quot;input&quot;).after(&quot;文本被选中！&quot;); }); var e = jQuery.Event(&quot;select&quot;); $(&quot;button&quot;).click(function(){ $(&quot;input&quot;).trigger(e); }); 效果动画 animate() 语法：animate(styles,speed,easing,callback); $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({left:&apos;250px&apos;}); }); 参数styles中的css样式值 见：链接 注释：使用 “+=” 或 “-=” 来创建相对动画(relative animations) 隐藏/显示 hide(speed,callback); show(speed,callback); toggle(speed,callback); speed参数可以取值：slow,fast,normal,毫秒;callback参数是隐藏或显示完成后所执行的函数名称。 &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;button class=&quot;btn1&quot;&gt;Toggle&lt;/button&gt; $(&quot;.btn1&quot;).click(function(){ $(&quot;p&quot;).toggle(); }); 淡入淡出 fadeIn(speed,callback); fadeOut(speed,callback); fadeToggle(speed,callback); fadeTo(speed,opacity,callback); speed参数可以取值：slow,fast,normal,毫秒;opacity必需，规定淡入或淡出的透明度，介于0.00与1.00;callback参数是隐藏或显示完成后所执行的函数名称。 $(&quot;.btn1&quot;).click(function(){ $(&quot;p&quot;).fadeTo(1000,0.4); }); 滑动 slideDown(speed,callback); slideUp(speed,callback); slideToggle(speed,callback); speed参数可以取值：slow,fast,normal,毫秒;callback参数是隐藏或显示完成后所执行的函数名称。 $(&quot;.btn1&quot;).click(function(){ $(&quot;p&quot;).slideToggle(); }); stop()停止当前正在运行的动画: $(&quot;#stop&quot;).click(function(){ $(&quot;#box&quot;).stop(); }); 链(Chaining)$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000); jQuery HTML获得内容 – text()、html()、val()&lt;p&gt;名称: &lt;input type=&quot;text&quot; id=&quot;test&quot; value=&quot;菜鸟教程&quot;&gt;&lt;/p&gt; &lt;button&gt;显示值&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ alert(&quot;值为: &quot; + $(&quot;#test&quot;).val()); }); }); text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 设置或返回属性 – attr()1.返回属性： &lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot; id=&quot;runoob&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt; &lt;button&gt;显示 href 属性的值&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ alert($(&quot;#runoob&quot;).attr(&quot;href&quot;)); }); }); 2.设置属性： $(&quot;button&quot;).click(function(){ $(&quot;img&quot;).attr(&quot;width&quot;,&quot;180&quot;); }); 3.设置多个属性： $(&quot;img&quot;).attr({width:&quot;50&quot;,height:&quot;80&quot;}); 添加元素append() &amp; prepend()append是在被选元素的结尾(仍然在内部)插入内容;prepend是在被选元素的开头(仍然在内部)插入内容 $(&quot;p&quot;).append(&quot; &lt;b&gt;Hello world!&lt;/b&gt;&quot;); after() &amp; before()after在被选元素的之后插入内容;before在被选元素之前插入内容 $(&quot;p&quot;).before(&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); 删除元素remove()删除被选元素及其子元素,该方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。 empty()从被选元素移除所有内容，包括所有文本和子节点: &lt;div id=&quot;div1&quot; style=&quot;height:100px;width:300px;border:1px solid black;background-color:yellow;&quot;&gt;这是 div 中的一些文本。 &lt;p&gt;这是在div中的一个段落。&lt;/p&gt; &lt;p&gt;这是在div中的另外一个段落。&lt;/p&gt; &lt;/div&gt; &lt;button&gt;清空div元素&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;#div1&quot;).empty(); }); }); clone()生成被选元素的副本，包含子节点、文本和属性: &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;button&gt;复制每个 p 元素，然后追加到 body 元素&lt;/button&gt; $(&quot;button&quot;).click(function(){ $(&quot;body&quot;).append($(&quot;p&quot;).clone()); }); addClass() &amp; removeClass() &amp; toggleClass()&lt;div class=&quot;div1&quot;&gt;这是一些文本。&lt;/div&gt; &lt;button&gt;为第一个div元素添加类&lt;/button&gt; .blue{ color:blue; } $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;#div1&quot;).addClass(&quot;blue&quot;); }); }); CSS()方法设置css属性： $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;,&quot;font-size&quot;,&quot;200%&quot;); 遍历祖先 (向上遍历)1.parent() 返回被选元素的直接父元素，只会向上一级对DOM树进行遍历。 2.parsents() 从父元素开始，返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。返回包含零个、一个元素或多个元素的jquery对象。 3.closest() 从当前元素开始，获得匹配选择器的第一个祖先元素，从当前元素开始沿DOM树向上。返回包含零个或一个元素的jquery对象。（和.parents有点相似） $(&apos;li.item-a&apos;).closest(&apos;ul&apos;).css(&apos;background-color&apos;, &apos;red&apos;); //整个ul中的li元素颜色都会变红 4.parsentsUntil() 返回介于两个给定元素之间的所有祖先元素。 后代 (向下遍历)1.children() 返回被选元素的所有直接子元素，该方法只会向下一级对DOM树进行遍历。 $(&quot;div&quot;).children(&quot;.selected&quot;).css(&quot;color&quot;,&quot;blue&quot;); 2.find() 返回被选元素的后代元素，一路向下直到最后一个后代。 `$(&apos;li.item-ii&apos;).find(&apos;li&apos;).css(&apos;background-color&apos;,&apos;red&apos;);` 也可以使用给定的jquery集合或元素来进行筛选： var $allListElements = $(&apos;li&apos;); $(&apos;li.item-ii&apos;).find($allListElements).css(&apos;background-color&apos;,&apos;red&apos;); 3.contents() 获得匹配元素集合中每个元素的子节点，包括文本和注释节点。 &lt;p&gt;Hello&lt;a href=&quot;#&quot;&gt;Apple&lt;/a&gt;,how are you doing?&lt;/p&gt; &lt;script&gt; $(&quot;p&quot;).contents().filter(function(){ return this.nodeType != 1; }).wrap(&quot;&lt;b/&gt;&quot;); &lt;/script&gt; 同胞 (水平遍历)1.siblings() 返回被选元素的所有同胞元素: $(&quot;p&quot;).siblings(&quot;.selected&quot;).css(&quot;background&quot;, &quot;yellow&quot;); //查找每个 p 元素的所有类名为 &quot;selected&quot; 的所有同胞元素： 2.next() 返回被选元素的下一个同胞元素 过滤 (缩小搜索元素的范围)1.first() 返回被选元素的首个元素。 2.last() 返回被选元素的最后一个元素。 3.eq() 返回被选元素中带有指定索引号的元素。 .blue{ background-color:blue; } $(&quot;body&quot;).find(&quot;div&quot;).eq(2).addClass(&quot;blue&quot;); 如果提供负数，则指示从集合结尾开始的位置，而不是从开头开始。 4.filter() 允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 &lt;div&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(&quot;div&quot;).css(&quot;background&quot;, &quot;#c8ebcc&quot;) .filter(&quot;.middle&quot;) .css(&quot;border-color&quot;, &quot;red&quot;); &lt;/script&gt; 5.not() 和filter()方法相反。 others1.add() 将元素添加到匹配元素的集合中: $(&quot;div&quot;).css(&quot;border&quot;, &quot;2px solid red&quot;) .add(&quot;p&quot;) .css(&quot;background&quot;, &quot;yellow&quot;); 2.each() 对jQuery对象进行迭代，为每个匹配元素执行函数。 $(&quot;button).click(function(){ $(&quot;li&quot;).each(function(){ alert($(this).text()) }); }); 3.end() 结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。 &lt;ul class=&quot;first&quot;&gt; &lt;li class=&quot;foo&quot;&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li class=&quot;bar&quot;&gt;list item 3&lt;/li&gt; &lt;/ul&gt; $(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;, &apos;red&apos;) .end().find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;); 说明: 这条命令链检索第一个列表中类名为foo的项目，并把它们的背景设置为红色。end()会将对象还原为调用find()之前的状态，所以第二个find()查找的是&lt;ul class=&quot;first&quot;&gt;内的.bar&#39;，而不是在列表的&lt;li class=&quot;foo&quot;&gt;中查找，并将匹配元素的背景设置为绿色。最后的结果是第一个列表中的项目1和项目3被设置了带颜色的背景，而第二个列表中的项目没有任何变化。 DOM元素方法index()返回指定元素相对于其他指定元素的index位置： &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Soda&lt;/li&gt; &lt;/ul&gt; $(&quot;li&quot;).click(function(){ alert($(this).index()); }); toArray()以数组的形式返回jQuery选择器匹配的元素: x = $(&quot;li&quot;).toArray() for(i=0;i&lt;x.length;i++){ alert(x[i].innerHTML); } size()返回被jQuery选择器匹配的元素的数量: $(document).ready(function(){ alert($(&quot;li&quot;).size()); }); //输出结果：3 get()获得由选择器指定的DOM元素: &lt;p&gt;This is a paragraph&lt;/p&gt; &lt;button&gt;获得p DOM元素&lt;/button&gt; &lt;div&gt;&lt;/div&gt; $(&quot;button&quot;).click(function(){ x = $(&quot;p&quot;).get(0); $(&quot;div&quot;).text(x.nodeName + &quot;: &quot; + x.innerHTML); }); //输出结果：P: This is a paragraph AJAX！！AJAX 是与服务器交换数据的技术，通过后台加载数据，它在不重载全部页面的情况下，实现了对部分网页的更新。 什么是AJAX?AJAX = 异步JavaScript和XML (Asynchronous JavaScript and XML) AJAX load()方法语法：$(selector).load(URL,data,callback); &lt;div id=&quot;div1&quot;&gt;使用jquery AJAX修改文本内容&lt;/div&gt; &lt;button&gt;获取外部内容&lt;/button&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;#div1&quot;).load(&quot;/try/ajax/demo_test.txt&quot;); }); //此处的url是我引用过来的 });","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"使用HBuilder","date":"2017-07-25T16:03:21.000Z","path":"2017/07/26/使用HBuilder/","text":"HBuilder下载地址：HBuilder官网 HBuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。HBuilder的编写用到了Java、C、Web和Ruby。HBuilder本身主体是由Java编写，它基于Eclipse，所以顺其自然地兼容了Eclipse的插件。 HBuilder设置外部web服务器测试移动Web1.打开开发工具 工具右上角更改开发视图模式为“边改边看模式” 打开设置web服务器 2.设置外置服务器 选择“外置Web服务器” ☞ 右边“新建” 编辑服务配置界面，“名称”随意，“浏览器运行URL”填写本机ip地址 3.查看IP地址并配置web服务器1.地址查看方式：在命令行中输入ipconfig，找到IPv4的地址 2.填写在URL中，如图所示（要在IP地址后面加上HBuilder使用的端口8020）： 3.使用新建的myWeb外部服务器 4.扫码测试在“web浏览器”网址右边有一个二维码标志，点击，使用手机扫描测试 注意： 扫码测试需要电脑和手机在同一个局域网下！！！ 电脑运行： 手机扫码运行：","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"学习Sass","date":"2017-07-25T13:03:33.000Z","path":"2017/07/25/学习Sass/","text":"CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。这不是锦上添花，而恰恰是雪中送炭。 目前主流的三个预处理器： Less Sass Stylus 安装SassRuby下载链接http://rubyinstaller.org/downloads 安装过程中请注意勾选 Add Ruby executables to your PATH 安装完成后运行cmd输入ruby -v测试有没有安装成功。 若安装成功，使用Ruby自带的RubyGems系统安装Sass和Compass gem install sass gem install compass 这样就安装好了！ 如下sass常用更新、查看版本、sass命令帮助等命令： gem update sass sass -v sass -h 编译SassSass编译有很多种方式，如命令行编译模式、sublime插件SASS-Build 、编译软件koala 、前端自动化软件codekit 、Grunt打造前端自动化工作流grunt-sass 、Gulp打造前端自动化工作流gulp-ruby-sass等。 命令行编译：//单文件转换命令 sass input.scss output.css //单文件监听命令 sass --watch input.scss:output.css //如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录： sass --watch app/sass:public/stylesheets 四种编译排版//未编译样式 .box { width: 300px; height: 400px; &amp;-title { height: 30px; line-height: 30px; } } nested 编译排版格式：/*命令行内容*/ sass style.scss:style.css --style nested /*编译过后样式*/ .box { width: 300px; height: 400px; } .box-title { height: 30px; line-height: 30px; } expanded 编译排版格式/*命令行内容*/ sass style.scss:style.css --style expanded /*编译过后样式*/ .box { width: 300px; height: 400px; } .box-title { height: 30px; line-height: 30px; } compact 编译排版格式/*命令行内容*/ sass style.scss:style.css --style compact /*编译过后样式*/ .box { width: 300px; height: 400px; } .box-title { height: 30px; line-height: 30px; } compressed 编译排版格式/*命令行内容*/ sass style.scss:style.css --style compressed /*编译过后样式*/ .box{width:300px;height:400px}.box-title{height:30px;line-height:30px} 在webstrom中使用sassfile ☛ settings ☞ Tools ☞ File Watchers 双击配置Sass 嵌套CSS规则sass文件: #content { article { h1 { color: #333 } p { margin-bottom: 1.4em } } aside { background-color: #EEE } } 编译成css后： #content article h1 { color: #333 } #content article p { margin-bottom: 1.4em } #content aside { background-color: #EEE } 父选择器的标识符&amp;article a { color: blue; &amp;:hover { color: red } } 当包含父选择器标识符的嵌套规则被打开时，他不会像后代选择器那样进行拼接，而是 &amp; 被父选择器直接替换： article a { color: blue; } article a:hover { color: red } 子组合选择器和同层组合选择器： &gt; 、 + 和 ~article section { margin: 5px } article &gt; section { border: 1px solid #ccc } 第一个选择器会选择article下的所有命中section选择器的元素。第二个选择器只会选择article下紧跟着的子元素中命中section选择器的元素。 header + p { font-size: 1.1em } 在上例中，你可以用同层相邻组合选择器 + 选择header元素后紧跟的p元素。 article ~ article { border-top: 1px dashed #ccc } 你也可以用同层全体组合选择器 ~ ，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素。 例子： article { ~ article { border-top: 1px dashed #ccc } &gt; section { background: #eee } dl &gt; { dt { color: #333 } dd { color: #555 } } nav + &amp; { margin-top: 0 } } sass解开组合之后： article ~ article { border-top: 1px dashed #ccc } article &gt; footer { background: #eee } article dl &gt; dt { color: #333 } article dl &gt; dd { color: #555 } nav + article { margin-top: 0 } 嵌套属性重复编写border-style border-width border-color等非常烦人，所以在sass中，只要像以下这样书写就行： nav{ border: { style: solid; width: 1px; color: #ccc; } } 规则： 把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。 优点： 属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。 导入Sass文件随着你的样式表越来越多，我们要把大量样式分拆到多个文件中，使用 @import 规则。 使用sass部分文件举例来说，你想导入 themes/_night-sky.scss 这个局部文件里的变量，你只需在样式表中写 @import &quot;themes/night-sky&quot;; 默认变量值;一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明： $link-color: blue; $link-color: red; a { color: $link-color; } 在上边的例子中，超链接的color会被设置为red。这可能并不是你想要的结果，假如你写了一个可被他人通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值。使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。 $fancybox-width: 400px !default; .fancybox { width: $fancybox-width; } 在上例中，如果用户在导入你的sass局部文件之前声明了一个$fancybox-width变量，那么你的局部文件中对$fancybox-width赋值400px的操作就无效。如果用户没有做这样的声明，则$fancybox-width将默认为400px。 静默注释body { color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */ } 混合器混合器使用 @mixin 标识符定义。 @mixin rounded-corners { -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px; } 然后就可以在样式表中通过 @include 来使用这个混合器。 notice { background-color: green; border: 2px solid #00aa00; @include rounded-corners; } sass最终生成： .notice { background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px; }","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML5 Web存储","date":"2017-07-24T06:02:21.000Z","path":"2017/07/24/HTML5-Web存储/","text":"HTML5使用JavaScript来存储和访问数据，提供了两种在客户端存储数据的新方法： localStorage –没有时间限制的数据存储。第二天、第二周或下一年之后，数据依然可用。 sessionStorage –针对一个session的数据存储。当用户关闭浏览器窗口后，数据会被删除。 localStorage方法对用户访问页面的次数进行计数： &lt;script&gt; if (localStorage.pagecount) { localStorage.pagecount=Number(localStorage.pagecount) +1; } else { localStorage.pagecount=1; } document.write(&quot;Visits &quot;+ localStorage.pagecount + &quot; time(s).&quot;); &lt;/script&gt; sessionStorage方法用户在当前 session 中访问页面的次数进行计数： &lt;script&gt; if(sessionStorage.pageCount){ sessionStorage.pageCount = Number(sessionStorage.pageCount) +1; } else { sessionStorage.pageCount = 1; } document.write(&quot;visits: &quot; + sessionStorage.pageCount + &quot; 次&quot;); &lt;/script&gt; 如何工作?早在1995,2010年，浏览器存储是利用cookie在浏览器上存储信息，但cookie仅限4k数据。 现如今的浏览器都很慷慨，都会提供5~10M（每个域）的存储空间。创建HTML5的本地存储时还充分考虑了Web应用（和移动应用）。所谓本地存储，就是指你的应用可以把数据存储在浏览器上，从而减少与服务器之间所需的通信。 如何做到的？ 使用这个API，页面可以在浏览器的本地存储中存储一个或多个键/值对； 然后用键来获取相应的值； 键/值对，就是key: &quot;pet&quot;, key就是键，pet就是对。 获取方法和设置方法(getItem和setItem)setItem方法，用于存储某个数据，只能是string类型的数据项。 localStorage.setItem(&quot;name&quot;,&quot;luya&quot;); localStorage.setItem(&quot;age&quot;,21); alert(localStorage.getItem(&quot;name&quot;)); //alert(parseInt(localStorage.getItem(&quot;age&quot;))); //输出：luya 看成一个关联数组//为键赋值 localStorage[&quot;name&quot;] = &quot;luya&quot;; //获取一个键存储的值,相当于getItem方法 var name = localStorage[&quot;name&quot;]; 另外两个特性length属性，localStorage中有多少数据项；key方法，给出localStorage中各个数据项的键。 for(var i=0;i&lt;localStorage.length;i++){ var key = localStorage.key(i); var value = localStorage[key]; alert(value); } 可以怎样使用？ 在我的新Twitter客户端，为了提高效率，我要用localStorage把Twitter搜索结果缓存起来。用户搜索时，会先搜索本地结果。这对移动用户很有帮助。 用户存储播放列表（影片、音乐等） 使用sessionStorage实现购物车 有一个非常酷的游戏，他可以在两个不同的浏览器窗口同时工作，使用localStorage完成状态同步 JSON JavaScript对象表示法（JavaScript Object Notation） JSON是存储和交换文本信息的语法，类似XML；JSON比XML更小、更快、更易解析。 JSON API只有两个方法：stringify 和 parse","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"JSP学习笔记","date":"2017-07-23T14:19:34.000Z","path":"2017/07/23/JSP学习笔记/","text":"JSP – Java Server Pages 区别jsp和servlet1.jsp就是在html里面写java代码，servlet就是在java里面写html代码。 2.servlet在java代码中通过HttpServletResponse对象动态输出HTML内容；jsp在静态HTML内容中嵌入Java代码，Java代码被动态执行后生成HTML内容。 3.两者通过MVC双剑合璧：MVC(Model-View-Controller) Controller(控制器) -负责转发请求，对请求进行处理 View(视图) -负责界面显示 Model(模型) -业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现 工具myeclipse,tomcat 使用myeclipse1.new – web project; 2.输入project name (imoocjsp); 3.打开imoocjsp 下的 Webroot 文件，双击index.jsp。删除pageEncoding=&quot;ISO-8859-1&quot;之后 使用 alt+/ 选择contentType,将其中charset值改为charset=utf-8;(解决中文编码问题) 4.点击图中红色区域内图标，选择Project – imoocjsp – add – Server – tomcat7 –ok; 5.启动Tomcat服务器，在地址栏输入：localhost:8080/imoocjsp/index.jsp JSP指令用来设置与整个JSP页面相关的属性。语法：&lt;%@ directive attribute=&quot;value&quot; %&gt; include 指令: &lt;%@ include file=&quot;url&quot; %&gt; 动作：&lt;jsp:include page=&quot;url&quot; flush=&quot;true|false&quot; /&gt; page(要包含的页面)； flush(被包含的页面是否从缓冲区读取) JSP注释 HTML注释： //客户端可见 JSP注释： &lt;%– html注释 –%&gt; //客户端不可见 JSP脚本注释： //单行注释 / ** /多行注释 JSP脚本写在&lt;% %&gt; 中的叫做JSP脚本。 &lt;% out.println(&quot;大家好，JSP脚本&quot;); %&gt; JSP声明在JSP页面中定义变量或者方法。语法：&lt;%! JAVA代码 %&gt; &lt;%! String s=&quot;张三&quot;; //声明了一个字符串变量 int add(int a,int b){ //声明了一个返回整型函数，实现两个整数的求和 return a+b; } %&gt; JSP表达式语法：&lt;%=表达式 %&gt;注意：表达式不以分号结束 做一个九九乘法表&lt;%! String printMultiTable() { String s=&quot;&quot;; for(int i=1;i&lt;=9;i++) { for(int j=1;j&lt;=i;j++) { s+=i+&quot;*&quot;+j+&quot;=&quot;+(i*j)+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;; } s+=&quot;&lt;br&gt;&quot;; } return s; } %&gt; &lt;h1&gt;九九乘法表&lt;/h1&gt;&lt;br&gt; &lt;%=printMultiTable() %&gt; JSP内置对象out对象 什么事缓冲区？ Buffer,所谓缓冲区就是内存的一块区域来保存临时数据。 &lt;% out.println(&quot;&lt;h2&gt;静夜思&lt;/h2&gt;&quot;); out.println(&quot;床前明月光&lt;br&gt;&quot;); out.clear(); out.println(&quot;疑是地上霜&lt;br&gt;&quot;); %&gt; 缓冲区大小：&lt;%=out.getBufferSize() %&gt;Byte&lt;br&gt; 缓冲区剩余大小：&lt;%=out.getRemaining() %&gt;&lt;br&gt; 缓冲区满时：&lt;%=out.isAutoFlush() %&gt;&lt;br&gt; get/postmethod=”get/post” get: 提交的数据最多不超过2KB，安全性较低但效率比post高。适合提交数据量不大。安全性不高的数据。比如：搜索、查询等功能。 post: 将用户提交的信息封装在HTML HEADER内。适合提交数据量大，安全性高的用户信息。比如：注册、修改、上传等功能。 用户名: 密码: request/response //login.jsp: &lt;form action=&quot;request.jsp&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 爱好:&lt;input type=&quot;checkbox&quot; name=&quot;favorite&quot; value=&quot;read&quot;&gt;读书 &lt;input type=&quot;checkbox&quot; name=&quot;favorite&quot; value=&quot;music&quot;&gt;音乐 &lt;input type=&quot;checkbox&quot; name=&quot;favorite&quot; value=&quot;movie&quot;&gt;电影 &lt;input type=&quot;checkbox&quot; name=&quot;favorite&quot; value=&quot;internet&quot;&gt;上网 &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;a href=&quot;request.jsp?username=lisi&quot;&gt;测试URL传参数&lt;/a&gt; //request.jsp: &lt;% request.setCharacterEncoding(&quot;utf-8&quot;); //解决中文乱码问题 %&gt; 用户：&lt;%=request.getParameter(&quot;username&quot;) %&gt;&lt;br/&gt; 爱好：&lt;% if(request.getParameterValues(&quot;favorite&quot;)!=null){ String[] favorites=request.getParameterValues(&quot;favorite&quot;); for(int i=0;i&lt;favorites.length;i++){ out.println(favorites[i]+&quot;&amp;nbsp;&amp;nbsp;&quot;); } } %&gt; %&gt; sessionapplicationpage对象JavaBeanjavabean是一种规范，而不是一种技术或工具。 创建JavaBean 新建一个Web Project –命名：JavaBeanDemo1 ； 新建一个package –命名：com.po ； 新建一个class –命名：Users ； 右键 – source – Generate getters and setters – Select All –ok ； 双击index.jsp – 使用page指令 &lt;%@ page import=&quot;com.po.Users&quot; %&gt; &lt;% Users user = new Users(); user.setUsername(&quot;admin&quot;); //设置用户名 user.setPassword(&quot;123456&quot;); //设置密码 %&gt; 用户名：&lt;%=user.getUsername() %&gt;&lt;br&gt; 密码：&lt;%=user.getPassword() %&gt;&lt;br&gt; JavaBean动作元素 &lt;jsp:useBean id=&quot;myUsers&quot; class=&quot;com.po.Users&quot; scope=&quot;page&quot; /&gt; &lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot; * &quot;/&gt; &lt;jsp:getProperty name=&quot;myUsers&quot; property=&quot; * &quot;/&gt;","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"git学习笔记","date":"2017-07-22T02:52:20.000Z","path":"2017/07/22/git学习笔记/","text":"Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 创建版本库(repository)首先在合适的地方(我选择在github/Git/usr中)，创建一个空目录： $ mkdir learngit $ cd learngit $ pwd /usr/learngit pwd命令用于显示当前目录 第二步，初始化仓库，在Git/usr中，输入命令 git init, 这样瞬间Git就把仓库建好了，而且会告诉你是一个空的仓库，此时你会看到多了一个.git目录 如果你没有看到，那是因为这个目录被隐藏了，用ls -ah命令就可以看到。 把文件添加到版本库先编写一个readme.txt 文件，内容如下 Git is a version control system. Git is free software. 第一步，把文件添加到仓库 $ git add readme.txt 第二步，把文件提交到仓库 $ git commit -m &quot;add readme.txt&quot; 修改readme.txt文件接着上面的内容，继续修改readme.txt文件，改成一下内容： Git is a distributed version control system. Git is free software. 掌握仓库当前的状态： $ git status 上图告诉我们，readme.txt被修改过,但还没有准备提交的修改 如果说过了很久，你忘了自己修改了什么内容，那么使用下面的命令就可以知道了： $ git diff &quot;文件名&quot; 接下来使用之前的 git add readme.txt , git commit -m &quot;add distributed&quot; 版本回退1.查看修改的历史记录(显示是从近到远)： $ git log 也可以加上参数 --pretty=oneline让历史记录看起来更简单。 2.退回上一个版本： $ git reset --hard HEAD^ 3.可是这个时候又想回到之前的版本怎么办，别急，只要你的命令行窗口没关掉，就往上找到append GPL 的 commit id是 ee0a0cff...(版本号只要前几位就行，git会自动查找) $ git reset --hard ee0a0cff 那要是命令行窗口关掉了呢？不怕，还是有办法的！Git提供了一个命令 git reflog 用来记录你的每一次命令。 删除文件$ git rm readme.txt 上传到github完整过程 –添加远程库echo &quot;#DemoWebsite&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin https://github.com/luyaJ/DemoWebsite.git git push -u origin master 分支管理创建others分支，并切换到others分支$ git checkout -b others 相当于下面的命令： $ git branch others $ git checkout others 查看当前分支$ git branch 切换回master分支$ git checkout master 合并分支$ git merge others 删除分支分支用完合并后就可以随意删除了： $ git branch -D others 总结 创建空目录三步走：mkdir 目录名字 ， cd 目录名字 ， pwd 初始化仓库：git init 添加文件到仓库：git add 文件名 提交文件到仓库：git commit -m “XXXX”(注意每次修改，如果不add到暂存区，那就不会加入到 commit中) 掌握仓库当前的状态：git status 查看文件修改内容： git diff “文件名” 查看修改的历史记录: git log 删除文件：git rm 文件名 最后附上廖雪峰老师的Git教程","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"用css实现几个小图标","date":"2017-07-21T05:25:59.000Z","path":"2017/07/21/用css实现几个小图标/","text":"1. 三角形 设置一个块元素大小为0，采用border属性，制作如下各种图形： //1.双色正方形 height: 0; width: 0; border-bottom: 100px solid indianred; border-left: 100px solid chocolate; //2.三色矩形 border-right: 100px solid darkcyan; //3.四色正方形 border-top: 100px solid plum; //4.三角形 height: 0; width: 0; border-bottom: 100px solid indianred; border-left: 100px solid transparent; border-right: 100px solid transparent; 2.陌陌轮廓使用圆角属性制作~直接上代码 height: 100px; width: 100px; background: darkgoldenrod; border-radius: 50% 50% 0; 进一步拓展，制作成小水滴： height: 100px; width: 100px; background: sandybrown; border-radius: 50% 50% 0; transform: rotate(45deg); 3.扭曲的正方形height: 100px; width: 100px; background: mediumslateblue; border-radius: 20px 12px 40px / 0.5em 3em; 其中的border-radius: 2em 1em 4em / 0.5em 3em;等价于： border-top-left-radius: 2em 0.5em; border-top-right-radius: 1em 3em; border-bottom-right-radius: 4em 0.5em; border-bottom-left-radius: 1em 3em; 注释: 如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。 4.箭头.demo{ width: 0; height: 0; border-top: 15px solid transparent; border-right: 15px solid red; -webkit-transform: rotate(10deg); -o-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); } .demo:after{ content: &quot;&quot;; position: absolute; border-top: 5px solid red; border-radius: 20px 0 0 0; top: -18px; left: -10px; width: 15px; height: 15px; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); } 5.小星星思想：三个三角形拼接而成，使用transform调整方向。 .star{ margin: 100px 0; color: red; height: 0; width: 0; border-right: 100px solid transparent; border-bottom: 70px solid darkkhaki; border-left: 100px solid transparent; -webkit-transform: rotate(35deg); -o-transform: rotate(35deg); -moz-transform: rotate(35deg); -ms-transform: rotate(35deg); } .star:before{ content: &apos;&apos;; height: 0; width: 0; border-bottom: 80px solid darkkhaki; border-left: 30px solid transparent; border-right: 30px solid transparent; position: absolute; top: -56px; left: -77px; -webkit-transform: rotate(-35deg); -moz-transform: rotate(-35deg); -ms-transform: rotate(-35deg); -o-transform: rotate(-35deg); } .star:after{ content: &apos;&apos;; width: 0; height: 0; border-right: 100px solid transparent; border-bottom: 70px solid darkkhaki; border-left: 100px solid transparent; position: absolute; color: red; top: 10px; left: -115px; -webkit-transform: rotate(-70deg); -moz-transform: rotate(-70deg); -ms-transform: rotate(-70deg); -o-transform: rotate(-70deg); } 6.心形.heart{ width: 100px; height: 90px; } .heart:before, .heart:after { position: absolute; content: &apos;&apos;; width: 50px; height: 80px; background: darksalmon; border-radius: 50px 50px 0 0; left: 50px; -webkit-transform: rotate(-45deg); -o-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -moz-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -ms-transform-origin: 0 100%; -o-transform-origin: 0 100%; transform-origin : 0 100%; } .heart:after{ left: 0; -webkit-transform: rotate(45deg); -o-transform: rotate(45deg); -ms-transform: rotate(45deg); -moz-transform: rotate(45deg); transform: rotate(45deg); -webkit-transform-origin: 100% 100%; -moz-transform-origin: 100% 100%; -ms-transform-origin: 100% 100%; -o-transform-origin: 100% 100%; transform-origin :100% 100%; } 7.十字架.cross{ height: 100px; width: 20px; background: mediumseagreen; margin-left: 50px; position: relative; } .cross:after{ background: mediumseagreen; content: &apos;&apos;; height: 20px; position: absolute; width: 80px; top: 30px; left: -30px; }","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Yilia主题优化","date":"2017-07-15T09:56:56.000Z","path":"2017/07/15/Yilia主题优化/","text":"过了大半年，该是要好好整理下自己的博客了。 github+hexo新建文章：$ hexo new &quot;新的文章&quot; 然后你就发现blog根目录下的source文件夹中的_post文件夹中多了一个 新的文章.md 文件 本地服务预览：$ hexo s //server （会监视文件变动并自动更新） 觉得自己的文章没问题后，就通过hexo g , hexo d生成和部署网页 清除缓存：$ hexo clean 生成：$ hexo g //generate 部署：$ hexo d //deploy 上面两部可以合起来 $ hexo d -g hexo所有主题传送门 markdown语法 markdownPad下载 推荐几个我觉得不错的主题： Ochuuunn / github下载 Random / github下载 安装主题$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 配置修改hexo根目录下的_config.yml ： theme : yilia 更新$ cd themes/yilia $ git pull 上面是老东西，下面是优化 添加文章目录添加css样式打开themes\\yilia\\source下的 main.2d7529.css文件(这里好像名字会不一样，没关系，找到.css文件就ok了)，在里面添加代码： /* 新添加的 */ #container .show-toc-btn,#container .toc-article{display:block} .toc-article{z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px}.toc-article .toc-close{font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc}.toc-article .toc-close:hover{color:#000}.toc-article .toc{font-size:12px;padding:0;line-height:20px}.toc-article .toc .toc-number{color:#333}.toc-article .toc .toc-text:hover{text-decoration:underline;color:#2a6496}.toc-article li{list-style-type:none}.toc-article .toc-level-1{margin:4px 0}.toc-article .toc-child{}@-moz-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@-webkit-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@-o-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}.show-toc-btn{display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9}.show-toc-btn .btn-bg{margin-top:2px;display:block;width:16px;height:14px;background:url(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%}.show-toc-btn .btn-text{color:#999;font-size:12px}.show-toc-btn:hover{cursor:pointer}.show-toc-btn:hover .btn-bg{background-position:0 -16px}.show-toc-btn:hover .btn-text{font-size:12px;color:#ea8010} .toc-article li ol, .toc-article li ul { margin-left: 30px; } .toc-article ol, .toc-article ul { margin: 10px 0; } 修改article.ejs文件打开themes\\yilia\\layout\\_partial文件夹下的article.ejs文件，在&lt;/header&gt; &lt;% } % 下面加入如下内容(注意插入的位置): &lt;!-- 目录内容 --&gt; &lt;% if (!index &amp;&amp; post.toc){ %&gt; &lt;p class=&quot;show-toc-btn&quot; id=&quot;show-toc-btn&quot; onclick=&quot;showToc();&quot; style=&quot;display:none&quot;&gt; &lt;span class=&quot;btn-bg&quot;&gt;&lt;/span&gt; &lt;span class=&quot;btn-text&quot;&gt;文章导航&lt;/span&gt; &lt;/p&gt; &lt;div id=&quot;toc-article&quot; class=&quot;toc-article&quot;&gt; &lt;span id=&quot;toc-close&quot; class=&quot;toc-close&quot; title=&quot;隐藏导航&quot; onclick=&quot;showBtn();&quot;&gt;×&lt;/span&gt; &lt;strong class=&quot;toc-title&quot;&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function showToc(){ var toc_article = document.getElementById(&quot;toc-article&quot;); var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;); toc_article.setAttribute(&quot;style&quot;,&quot;display:block&quot;); show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:none&quot;); }; function showBtn(){ var toc_article = document.getElementById(&quot;toc-article&quot;); var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;); toc_article.setAttribute(&quot;style&quot;,&quot;display:none&quot;); show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:block&quot;); }; &lt;/script&gt; &lt;% } %&gt; &lt;!-- 目录内容结束 --&gt; 如果想要文章显示目录，要在每篇文章的开头加入：toc: true 添加其他一些东西添加“关于”$ hexo new page &quot;about&quot; 此时，source中就会多出一个文件夹，名为about,可以在里面编辑内容 在themes/yilia/_config.yml添加下面内容： menu: 关于: /about 添加RSS$ npm install hexo-generator-feed --save 注意完整的输入上面的代码，--save不能省，否则插件信息不能写入package.json，之后hexo clean 、hexo g,查看public文件夹，里面多了一个atom.xml文件夹表示成功。 添加sitemap$ npm install hexo-generator-sitemap --save hexo clean 、hexo g,查看public文件夹，可以看到sitemap.xml文件。 sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。 添加本站访问次数在themes/yilia/layout/_partial 下找到footer.ejs , 在里面加入以下代码： &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; 文章模板打开hexo/scaffolds/post.md , 可以看到： --- title: {{ title }} date: {{ date }} tags: --- 做以下的修改，每次自动生成目录： --- title: {{ title }} date: {{ date }} tags: toc: true --- 注： 如果想要多个tag，则以这样的格式显示tages: [js,css] 给网页加ico图标 增加网站标题栏logo，很简单。将图片改成32*32格式的ico图标（这里我是在线转换的） 在文件中找到E:\\blog\\themes\\yilia\\layout\\_partial，再找到head.ejs,在里面增加语句&lt;link rel=&quot;shortcut icon&quot; href=&quot;图片地址&quot;&gt; 注意： 如果把ico图标放在网站根目录下，那么浏览器会不停的搜索网站根目录。","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"软件测试初学","date":"2017-05-24T15:12:30.000Z","path":"2017/05/24/软件测试初学/","text":"软件缺陷常见问题 统一性中英文问题 容错性互动性 用户输入信息有误时，按“确定”后，所有信息被清空(这种情况要避免) 对于所有的删除信息在删除之前都要给出是否删除确认的提示或者放弃的提示。 危险操作之前，提醒 改变数据状态，提醒 如填写资料有错误的时候，应该能够提示错误的位置，让用户知道到底是哪些地方输入的不正确 用户体验使用的提示信息要通俗易懂 兼容性： 操作系统版本 屏幕分辨率 网络类型(wifi,3G,4G) 易用性对于要求用户大量录入信息的页面，要支持Tab键的输入，Tab键的走向要一般要遵循从做左到右，从上到下的的原则 安全性： 登录网站进入其内部网页后，直接拷贝网址，然后粘贴到另一IE 窗口输入，在其他机器上看是否可以绕过登录直接访问 对于需要登录的系统，在用户不操作的一定时间内，出于安全性考虑，最好要让用户重新登录才能重新使用该系统 有些文件在ini等配置文件中写出了管理员口令密码等信息，而且是明文的!这是一个安全隐患 ！！！所有软件测试都是建立在业务之上的 等价类概念：是指把程序的输入域根据等价类原则划分成若干部分，然后从每个部分中选取少数具有代表性的数据作为测试输入数据的一种方法。 有效等价类 无效等价类 Junit单元测试测试用例不是用来证明你是对的，而是用来证明你没错。 入门：1.新建一个类： File → Java Project : name (JUnit_Test) → 在src下new Package : name (JunitTest) → new class : name (Calculator) → 敲代码： package JunitTest; public class Calculator { public int add(int a,int b){ return a+b; } public int subtract(int a,int b){ return a-b; } public int multiply(int a,int b){ return a*b; } public int divide(int a,int b){ return a/b; } } 2.导入JUnit jar包： JUnit_Test → Build Path → Add Libraries… → JUnit → Next&gt; → Finish 3.JunitTest → new : JUnit Test Case →输入测试工作区的名字 Name : (AddSubTest) , Class under test : name (Calculator) → Finish 4.运行测试用例： 右键 → Run AS → Junit Test → 结果显示，测试工作都运行通过 第一个测试用例：","tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"}]},{"title":"JS实现轮播图","date":"2017-01-31T08:10:42.000Z","path":"2017/01/31/JS实现轮播图/","text":"这个轮播图是在2016年12月完成的，是我用js完成的第一个小东西。 html代码实现&lt;div id=&quot;content&quot;&gt; &lt;div id=&quot;images&quot; style=&quot;left: -600px;&quot;&gt; &lt;img src=&quot;images/5.jpg&quot;&gt; &lt;img src=&quot;images/1.jpg&quot;&gt; &lt;img src=&quot;images/2.jpg&quot;&gt; &lt;img src=&quot;images/3.jpg&quot;&gt; &lt;img src=&quot;images/4.jpg&quot;&gt; &lt;img src=&quot;images/5.jpg&quot;&gt; &lt;img src=&quot;images/1.jpg&quot;&gt; &lt;/div&gt; &lt;div id=&quot;circle&quot;&gt; &lt;span class=&quot;on&quot; index=&quot;1&quot;&gt;&lt;/span&gt; &lt;span index=&quot;2&quot;&gt;&lt;/span&gt; &lt;span index=&quot;3&quot;&gt;&lt;/span&gt; &lt;span index=&quot;4&quot;&gt;&lt;/span&gt; &lt;span index=&quot;5&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;btn&quot; id=&quot;btn_l&quot;&gt;&amp;lt;&lt;/div&gt; &lt;div class=&quot;btn&quot; id=&quot;btn_r&quot;&gt;&amp;gt;&lt;/div&gt; &lt;/div&gt; css部分代码实现 1.”content” 处设置相对位置：position:relative; 图片展示为只显示一张图片，所以溢出content容器部分使用属性：overflow:hidden; 2.左、右按钮部分代码： position: relative; cursor: pointer; //鼠标移上去，显示手指妆 height: 50px; width: 30px; background: rgba(0,0,0,0.3); top: 50%; font-size: 40px; text-align: center; line-height: 50px; display: none; //当鼠标移上去时，btn出现 color: #fff; javascript部分代码实现点击&lt; &gt;按钮让图片左右移动function animate(offset){ var newLeft = parseInt(images.style.left) + offset; images.style.left = newLeft + &apos;px&apos;; if (newLeft&lt;-3000) { images.style.left = -600 + &apos;px&apos;; } if (newLeft&gt;-600) { images.style.left = -3000 + &apos;px&apos;; } } btn_l.onclick=function(){ animate(600); } btn_r.onclick=function(){ animate(-600); } if循环语句是实现图片无限循环； 这时，轮播图可以实现左右点击，图片相应变化的功能。 设置轮播图的定时器var timer; function play(){ timer = setInterval(function() { btn_r.onclick() },3000) //每3000ms图片自动移动 } play(); 使用setIntervel()设置定时器。 清除轮播图的定时器function stop() { clearInterval(timer); } content.onmouseover = stop; content.onmouseout = play; 图片自动移动时，当把鼠标悬停在content内时，图片暂停移动。 小圆点随图片变化相应变化function showCircle(){ for (var i=0;i&lt;circle.length;i++){ if(circle[i].className==&apos;on&apos;){ circle[i].className=&apos;&apos;; } } circle[index-1].className=&apos;on&apos;; } for循环用来清除之前circle的样式； 这时，点击&lt; &gt; 按钮小圆点会随图片相应点亮。 for (var i=0;i&lt;circle.length;i++){ circle[i].onclick=function(){ var clickIndex=parseInt(this.getAttribute(&apos;index&apos;)); var offset=600*(index-clickIndex); animate(offset); index=clickIndex; showCircle(); } } 利用getAttribute(‘’)获取自定义index，之后 btn_l.onclick=function(){ index -= 1; if(index&lt;1){ index=5; } showCircle(); animate(600); } btn_r.onclick=function(){ index += 1; if(index&gt;5){ index=1; } showCircle(); animate(-600); }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"用github+hexo搭建博客","date":"2017-01-30T14:44:59.000Z","path":"2017/01/30/用github-hexo搭建博客/","text":"2016年月底第一次正式开始搭建博客，在学长和另一个小伙伴的帮助下，我初次认识github+hexo，被它给吸引。寒假开始后，就在准备换主题，因为我对原始主题实在无爱，强迫症越来越严重的我，不换好主题坚持不做笔记（无奈脸）。刚刚换好主题的我，觉得之前自己用了好几个晚上都没有换好主题的自己简直是傻bi（给自己一个黑人问号），不过好在自己现在换好了主题，赶紧做笔记，谨防自己忘了。 清除，生成，部署123$ hexo clean or(hexo c)$ hexo generate$ hexo deploy 谨记：每次更改了一些信息后都要用这三步进行部署 安装yilia主题1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 安装好后，在_config.yml下修改theme：landscape为theme：yilia 写文章 找到blog ☞ sources ☞ _post ☞ 写博客 博客开头格式(以下为例子)：title: xxxdata: xxxx-xx-xxtags: xxxx 如果文章较长，如果全都在主页显示，就会很累赘，浏览也不是很方便，那么就可以在每篇文章中加入&lt;!--more--&gt; 文章写好直接执行下面命令即可直接发布文章$ hexo d -g 注意1.常用命令： hexo new “post name” （新建文章） hexo help （查看帮助） hexo version （查看hexo的版本） 2.Markdown语法参考链接： 链接 ● Hexo主题Yilia","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}]